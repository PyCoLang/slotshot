# SlotShot - A Tetris-inspired shooter game for C64 (Optimized Version)
# Controls: Joystick Port 2, W/S, or Up/Down to move cannon
#           Fire button or SPACE to shoot
# Fill the gaps to make columns disappear!
#
# OPTIMIZATION FEATURES:
# - Color RAM only rendering (screen chars filled once with CHAR_BLOCK)
# - IRQ-driven sprite movement for smooth cannon and bullet animation
# - Shared ZP variables between main loop and IRQ handler

# Include RLE decompressor, image data
include("rle")
include("slotshot_image_rle")
# CRITICAL: Song BEFORE musicplayer for feature-based DCE!
include("slotshot_music")
include("slotshot_gameover_music")
include("slotshot_highscore_music")
include("musicplayer")

# =============================================================================
# MEMORY LAYOUT - See work/memory_map.md for complete memory map!
# =============================================================================
SCREEN = 0xC400           # Screen RAM in bank 3
CHARSET_RAM = 0xC800      # Custom charset location in bank 3 (shared with title)
SPRITE_DATA_ADDR = 0xC000 # Sprite data at start of bank 3
SPRITE_POINTER_BASE = 0xC7F8  # Sprite pointers (SCREEN + $3F8)
SPRITE_BLOCK = 0          # Block 0 within bank

# Color RAM (always at $D800, not banked)
COLOR = 0xD800

# CIA1 registers
CIA1_TA_LO = 0xDC04           # Timer A low byte (~1MHz, excellent entropy source)
CIA1_TA_HI = 0xDC05           # Timer A high byte
CIA1_ICR = 0xDC0D

# Work buffer memory - use $0400 area (default screen RAM, safe from stack!)
# VIC Bank 3 uses $C400 for screen, so $0400-$07FF is free for buffers
COLUMN_BUFFER_ADDR = 0x0400   # 40 bytes for column blit buffer ($0400-$0427)
COLUMN_POOL_ADDR = 0x0428     # 960 bytes for pre-generated column patterns ($0428-$07E7)

# Column pool configuration
COLUMN_POOL_SIZE = 87         # Number of pre-generated column patterns (87 * 11 = 957 bytes)
COLUMN_ENTRY_SIZE = 11        # Bytes per entry: 1 block count + 10 row colors
MAX_HOLES = 4                 # Maximum holes per column (1-4 random)
MAX_HOLES_MASK = 3            # Bitmask for holes (0-3, then +1 = 1-4)

# Random state in safe user ZP area (16-bit for Galois LFSR)
RANDOM_STATE_ADDR = 0xFB       # $FB-$FC for 16-bit LFSR state
RANDOM_WEYL_ADDR = 0xFD        # $FD-$FE for 16-bit Weyl sequence (breaks LFSR linearity)

KERNAL_RPTFLG = 0x028A  # $00=default (CRSR/SPACE only), $80=all keys, $40=none

# =============================================================================
# VIC REGISTERS
# =============================================================================
# Screen colors
BORDER = 0xD020
BACKGROUND = 0xD021

# VIC control registers
VIC_CTRL1 = 0xD011        # Control register 1 (bit 6 = ECM, bit 7 = raster MSB)
VIC_CTRL2 = 0xD016        # Control register 2 (bit 0-2 = X scroll, bit 3 = 40/38 col mode)
VIC_MEMPTR = 0xD018       # Memory control register (screen/charset pointers)
VIC_RASTER = 0xD012       # Raster line register

# ECM background color registers
VIC_BG1 = 0xD022          # Background color 1 (for chars 64-127)
VIC_BG2 = 0xD023          # Background color 2 (for chars 128-191)
VIC_BG3 = 0xD024          # Background color 3 (for chars 192-255)

# VIC interrupt registers
VIC_IRQ_STATUS = 0xD019   # Interrupt status/acknowledge
VIC_IRQ_ENABLE = 0xD01A   # Interrupt enable
VIC_DEN = 0x10            # Display Enable bit (bit 4 of $D011)

# =============================================================================
# SPRITE REGISTERS
# =============================================================================
SPRITE_X = 0xD000         # Sprite 0-7 X positions (D000, D002, D004...)
SPRITE_Y = 0xD001         # Sprite 0-7 Y positions (D001, D003, D005...)
SPRITE_X_MSB = 0xD010     # X position MSB for all sprites
SPRITE_ENABLE = 0xD015    # Sprite enable register
SPRITE_EXPAND_Y = 0xD017  # Sprite Y expansion
SPRITE_EXPAND_X = 0xD01D  # Sprite X expansion
SPRITE_PRIORITY = 0xD01B  # Sprite priority (0=sprite in front)
SPRITE_MULTICOLOR = 0xD01C # Sprite multicolor mode
SPRITE_MC1 = 0xD025       # Sprite multicolor 1 (shared)
SPRITE_MC2 = 0xD026       # Sprite multicolor 2 (shared)
SPRITE_COLOR_0 = 0xD027   # Sprite 0 color (base address, +1 for each sprite)

# =============================================================================
# CIA REGISTERS
# =============================================================================
CIA2_PRA = 0xDD00         # CIA2 Port A - VIC bank selection

# =============================================================================
# CPU REGISTERS
# =============================================================================
CPU_PORT = 0x01           # CPU port (bit 0 = RAM/ROM banking)

# =============================================================================
# ROM ACCESS ADDRESSES (when I/O disabled)
# =============================================================================
CHAR_ROM = 0xD000         # Character ROM (when I/O disabled)

# =============================================================================
# SCREEN DIMENSIONS
# =============================================================================
SCREEN_WIDTH = 40
SCREEN_HEIGHT = 25

# Play area: 2x2 character blocks
TITLE_ROWS = 2            # Rows 0-1: title bar
STATUS_ROWS = 3           # Rows 22-24: status bar
PLAY_ROWS = 20            # Rows 2-21: play area (10 blocks high)
PLAY_TOP = 2              # First play row

# Grid dimensions (in 2x2 blocks)
GRID_WIDTH = 20           # 20 block columns (col 0 is under cannon!)
GRID_HEIGHT = 10          # 10 block rows
CANNON_COL = 0            # Cannon at leftmost position

# Block size
BLOCK_WIDTH = 2           # Characters per block
BLOCK_HEIGHT = 2          # Characters per block

# =============================================================================
# SPRITE COORDINATES
# =============================================================================
SPRITE_X_OFFSET = 24      # Add to screen X to get sprite X
SPRITE_Y_OFFSET = 50      # Add to screen Y to get sprite Y
CANNON_SPRITE_X = 24      # Cannon sprite X position (fixed, at left edge)

# =============================================================================
# GAME PHYSICS
# =============================================================================
BULLET_SPEED = 8          # Bullet speed (pixels per frame)

# =============================================================================
# CHARACTER CODES (screen codes)
# =============================================================================
# ECM mode: only chars 0-63 visible, bits 6-7 select background color
CHAR_SPACE = 32           # Empty space

# Block corner characters (custom chars 60-63) - rounded corners with 1px border
# Using 60-63 (< = > ?) to avoid overwriting letters A-Z (1-26)
CHAR_BLOCK_TL = 60        # Top-left corner
CHAR_BLOCK_TR = 61        # Top-right corner
CHAR_BLOCK_BL = 62        # Bottom-left corner
CHAR_BLOCK_BR = 63        # Bottom-right corner

# Progress bar character (custom char 59) - thin line at bottom of character
CHAR_PROGRESS = 59        # Progress bar segment

# Progress bar configuration
PROGRESS_BAR_WIDTH = 40   # Full screen width
PROGRESS_BAR_ROW = 22     # Status bar first row
PROGRESS_BAR_START = 0    # Starting X position (left edge)

# ECM background select offsets (add to char code)
BG_PLAY = 0               # Background 0 ($D021) - play area (black)
BG_TITLE = 64             # Background 1 ($D022) - title bar (blue)
BG_STATUS = 128           # Background 2 ($D023) - status bar (dark grey)
BG_HIGHLIGHT = 192         # Background 3 ($D024)

# =============================================================================
# KEY CODES (PETSCII)
# =============================================================================
KEY_UP = 145
KEY_DOWN = 17
KEY_W = 87
KEY_S = 83
KEY_W_LOWER = 119
KEY_S_LOWER = 115
KEY_P = 80
KEY_P_LOWER = 112
KEY_Q = 81
KEY_Q_LOWER = 113
KEY_SPACE = 32
KEY_RETURN = 13

# =============================================================================
# JOYSTICK PORT 2 (directly injects keys into keyboard buffer)
# =============================================================================
JOY_PORT = 0xDC00             # CIA1 Port A - directly read in IRQ

# Joystick bit masks (directly defined here, active LOW = 0 means pressed)
JOY_UP_MASK = 0x01
JOY_DOWN_MASK = 0x02
JOY_FIRE_MASK = 0x10

# Keyboard buffer addresses (Kernal locations)
KBD_BUFFER = 0x0277           # 10-byte keyboard buffer
KBD_COUNT = 0xC6              # Number of chars in buffer (NDX)

# Jiffy clock addresses (for elapsed time display)
JIFFY_HI_ADDR = 0xA1          # Jiffy clock middle byte (big-endian!)
JIFFY_LO_ADDR = 0xA2          # Jiffy clock low byte (changes at 60Hz)

# Joystick repeat timing (in CIA1 ticks, 60Hz)
JOY_INITIAL_DELAY = 12        # ~0.24s before repeat starts
JOY_REPEAT_RATE = 4           # ~0.08s between repeats (faster for games)

# =============================================================================
# GAME TIMING
# =============================================================================
INITIAL_COLUMNS = 7         # Number of columns to spawn at game start
INITIAL_SCORE = 9           # Starting score (each shot costs 1 point)

# Raster position for sprite updates
IRQ_RASTER_TOP = 10
IRQ_RASTER_MUSIC = 120
IRQ_RASTER_PLAY_AREA_BOTTOM = 226         # Sprite updates (timing not critical)
IRQ_RASTER_BOTTOM = 250

# =============================================================================
# COLORS (C64 palette)
# =============================================================================
BLACK = 0
WHITE = 1
RED = 2
CYAN = 3
PURPLE = 4
GREEN = 5
BLUE = 6
YELLOW = 7
ORANGE = 8
BROWN = 9
LIGHT_RED = 10
DARK_GREY = 11
GREY = 12
LIGHT_GREEN = 13
LIGHT_BLUE = 14
LIGHT_GREY = 15

# =============================================================================
# COLOR_RAM CONFIGURATION
# =============================================================================
COLOR_SCREEN_BG = BLACK
COLOR_SCREEN_BORDER = DARK_GREY
COLOR_TITLE_BG = BLUE
COLOR_TITLE_TEXT = WHITE
COLOR_STATUS_BG = DARK_GREY
COLOR_STATUS_TEXT = LIGHT_GREY
COLOR_STATUS_TEXT_HIGHLIGHT = WHITE
COLOR_HIGHLIGHT_BG = LIGHT_GREY
COLOR_STATUS_SHORTCUTS_HIGHLIGHT = ORANGE
COLOR_STATUS_SHORTCUTS = YELLOW
COLOR_CANNON = YELLOW
COLOR_BULLET = WHITE
COLOR_BULLET_YELLOW = YELLOW
COLOR_BULLET_BLUE = BLUE

# =============================================================================
# SPECIAL BULLET CONFIGURATION
# =============================================================================
# 255 * 0.10 ≈ 25 (for byte comparison)
# 25 + 255 * 0.20 ≈ 63 (cumulative threshold)
YELLOW_CHANCE_THRESHOLD = 15
BLUE_CHANCE_THRESHOLD = 60

# Yellow bullet states (3-state machine):
# State 0: Looking for first WALL (passes through empty space before first wall)
# State 1: IN WALL - passing through wall blocks, looking for empty space after wall
# State 2: IN EMPTY (after wall) - looking for end of empty area or next wall
# State 3: AS WHITE - no gap found in row, behave like white bullet
YELLOW_STATE_BEFORE_WALL = 0
YELLOW_STATE_IN_WALL = 1
YELLOW_STATE_IN_EMPTY = 2
YELLOW_STATE_AS_WHITE = 3

# "Next" indicator character codes (custom chars with embedded letters)
CHAR_NEXT_TL = 39                 # Block top-left with "n"
CHAR_NEXT_TR = 40                 # Block top-right with "e"
CHAR_NEXT_BL = 41                 # Block bottom-left with "x"
CHAR_NEXT_BR = 42                 # Block bottom-right with "t"
COLOR_SPARKLE_1 = GREY        # Sparkle phase 1 (darker)
COLOR_SPARKLE_2 = LIGHT_GREY  # Sparkle phase 2 (brighter)
COLOR_GAME_OVER_FLASH = RED

# HIGH SCORE CONFIGURATION
COLOR_HIGH_SCORE_LABEL = GREY
COLOR_HIGH_SCORE = GREY
SCORE_DISPLAY_TOGGLE_FRAMES = 100

# Block colors mask (8 colors = power-of-2 for fast bitmask selection)
BLOCK_COLORS_MASK = 7         # Bitmask for 8 colors (0-7)

# Menu colors
COLOR_MENU_NORMAL = LIGHT_BLUE
COLOR_MENU_SELECTED = LIGHT_GREY
COLOR_MENU_BG = BLACK

# Star sprite color
STAR_COLOR = LIGHT_GREY

# =============================================================================
# TITLE SCREEN CONFIGURATION (Raster Split Bitmap/Text)
# =============================================================================
# Uses VIC Bank 3 ($C000-$FFFF) - same as game, but bitmap mode
# In bitmap mode: screen RAM holds colors, bitmap holds pixels
BITMAP_ADDR = 0xE000        # Bitmap data (shares location with charset in text mode)

# Raster split lines (visible area ~51-250, each char row = 8 lines)
# 25 rows total, bottom 4 rows (rows 21-24) in text mode for menu
# Row 21 starts at: 51 + (21 * 8) = 219
TITLE_RASTER_TO_BITMAP = 15       # Upper border - switch to bitmap
TITLE_RASTER_BEFORE_SWITCH = 187  # Disable CIA1 before mode switch
TITLE_RASTER_TO_TEXT = 209        # Switch to text mode

# VIC memory pointer values (for $D018) - Bank 3
# Bank 3: base $C000, offsets relative to $C000
# Screen at $C400: offset $0400 → bits 7-4 = %0001
# Charset at $C800: offset $0800 → bits 3-1 = %001 (shared by game AND title)
# Bitmap at $E000: offset $2000 → bit 3 = 1
# Note: In Bank 3, there's NO character ROM hole - ROM copied to $C800 (CHARSET_RAM)
GAME_MEMPTR = 0x12                # %0001 0010 - Screen $C400, Charset $C800
TITLE_MEMPTR_TEXT = 0x12          # %0001 0010 - Screen $C400, Charset $C800 (same!)
TITLE_MEMPTR_BITMAP = 0x18        # %0001 1000 - Screen $C400, Bitmap $E000

# VIC Control bits
TITLE_VIC_BITMAP_MODE = 0x20      # $D011 bit 5
TITLE_VIC_MULTICOLOR = 0x10       # $D016 bit 4
TITLE_VIC_ECM_MODE = 0x40         # $D011 bit 6 (must be OFF for bitmap!)

# Menu configuration
MENU_ITEM_COUNT = 4               # Play, Story, About, Donate
MENU_ROW_START = 21               # First menu row (screen row)

# =============================================================================
# SPRITE BLOCK INDICES
# =============================================================================

# Sprite block indices (within VIC bank)
CANNON_BLOCK_READY = 0     # Block 0: cannon ready ($C000)
CANNON_BLOCK_FIRED = 1     # Block 1: cannon fired ($C040)
BULLET_BLOCK = 2           # Block 2: bullet ($C080)
SPARKLE_BLOCK = 3          # Block 3: sparkle ($C0C0)
STAR_BLOCK = 4             # Block 4: star ($C100) - used for title screen stars

# Sparkle effect constants
SPARKLE_PHASE_MAX = 3       # Color fade phases (1=dark, 2=light, 3=dark again)
SPARKLE_SPAWN_CHANCE = 210  # Higher = rarer (200 ≈ 22% per frame when free)

# =============================================================================
# SHARED ZERO PAGE VARIABLES (IRQ <-> Main loop communication)
# PyCo uses $02-$29 (including LEAF_ZP $22-$29), user available: $2A-$56 (45 bytes)
# =============================================================================
# Bullet state variables
ZP_BULLET_ACTIVE = 0x2A    # byte: 0=inactive, 1=active
ZP_BULLET_X = 0x2B         # word: bullet X position (16-bit, 2 bytes)
ZP_BULLET_Y = 0x2D         # byte: bullet Y position (pixels)
ZP_BULLET_ROW = 0x2E       # byte: grid row at time of firing (0-9, fixed!)
ZP_BULLET_ROW_BASE = 0x4C  # word: row_offset for bullet_row (cached at fire time) - IRQ optimization
ZP_BULLET_HIT_COL = 0x36   # byte: 255=no hit, 0-19=hit column (0=game over)

# Cannon state variables
ZP_CANNON_TARGET_Y = 0x30  # byte: target Y position (pixels)
ZP_CANNON_CURRENT_Y = 0x31 # byte: current Y position (smooth interpolation)
ZP_CANNON_ROW = 0x32       # byte: cannon grid row (0-9)

# Sprite control
ZP_SPRITE_ENABLE = 0x33    # byte: sprite enable shadow register (game sprites 0-2 only)
ZP_STAR_MASK = 0x39        # byte: star sprite enable mask (sprites 3-7)

# Sparkle ZP state - sprite 2 control
ZP_SPARKLE_PHASE = 0x38     # byte: sparkle phase (0=off, 1-3=animating)
ZP_SPARKLE_POS = 0x4A       # word: sparkle screen position (for IRQ validation)

# Joystick temp
ZP_JOY_TMP = 0x34        # byte: direction bits (bit 0=up, 1=down, 2=fire)
# Joystick repeat delay counter (handled in IRQ for consistent timing)
ZP_JOY_DELAY = 0x37        # byte: frames until next repeat allowed

# Game timer (IRQ-based, immune to jiffy clock overflow)
ZP_FRAME_COUNTER = 0x3E    # byte: frames since last second (0-59, CIA1 always 60Hz)
ZP_GAME_SECONDS = 0x3F     # word: total elapsed seconds (max ~18 hours)

# Sound effects state (ZP for fast IRQ access)
ZP_SFX_ACTIVE = 0x41       # byte: 0=off, 1=playing, 3=arpeggio
ZP_SFX_TIMER = 0x42        # byte: remaining notes (arpeggio) or frames (normal)
ZP_SFX_FREQ = 0x43         # word: current frequency (16-bit)
ZP_SFX_DELTA = 0x45        # sbyte: frequency delta per note (signed)
ZP_SFX_PHASE = 0x46        # byte: frame counter within current note/silence
ZP_SFX_PENDING = 0x47      # byte: frames to wait before starting clear sound
ZP_SFX_NOTE_LEN = 0x48     # byte: note length in frames (bi-bip mode)

# Paused
ZP_PAUSED = 0x35           # byte: pause state (0=running, 1=paused)

# Yellow bullet state (free range: $3A-$3D)
ZP_BULLET_TYPE = 0x3A      # byte: current bullet type (0=white, 1=yellow)
ZP_NEXT_BULLET_TYPE = 0x3B # byte: next bullet type to fire (shown in "Next" indicator)
ZP_YELLOW_STATE = 0x3C     # byte: yellow bullet state (0=in wall, 1=in empty)
ZP_YELLOW_LAST_EMPTY = 0x3D # byte: last empty column found by yellow bullet

ZP_MENU_SELECTED = 0x49    # byte: selected menu item (0-3)

# =============================================================================
# CASCADE STATE MACHINE CONSTANTS
# =============================================================================
CASCADE_IDLE = 0        # No cascade active
CASCADE_SCAN = 1        # Scanning for cascade opportunities
CASCADE_SLIDE = 2       # Animate horizontal slide (smooth, 1 char at a time)
CASCADE_SETTLE = 3      # Wait after slide
CASCADE_CHECK = 4       # Check for new complete columns

# =============================================================================
# SCORE CONSTANTS
# =============================================================================
SCORE_COLUMN_CLEAR = 10     # Base points for clearing a column
SCORE_CASCADE_CLEAR = 15    # Base points for clearing a column via cascade
SCORE_LEVEL_BONUS = 5       # Additional points per level (added to base)

# =============================================================================
# COLUMN NUMBER CONSTANTS
# =============================================================================
COLUMN_START_MUSIC = 15
COLUMN_HISTERESIS = 3

# =============================================================================
# GLOBAL TUPLES (data stored directly - no preprocessor constants needed!)
# =============================================================================

# Row offset lookup (25 rows)
row_offset_data: tuple[word] = (
    0, 40, 80, 120, 160, 200, 240, 280, 320, 360,
    400, 440, 480, 520, 560, 600, 640, 680, 720, 760,
    800, 840, 880, 920, 960
)

# Colors
dying_colors_data: tuple[byte] = (GREY, LIGHT_GREY, GREY, LIGHT_GREY, GREY, WHITE, BLACK)
block_colors_data: tuple[byte] = (RED, CYAN, PURPLE, GREEN, ORANGE, LIGHT_GREEN, LIGHT_BLUE, LIGHT_RED)
commodore_rainbow_data: tuple[byte] = (
    RED, RED, RED, RED, RED, RED, RED, RED,
    ORANGE, ORANGE, ORANGE, ORANGE, ORANGE, ORANGE, ORANGE, ORANGE,
    YELLOW, YELLOW, YELLOW, YELLOW, YELLOW, YELLOW, YELLOW, YELLOW,
    GREEN, GREEN, GREEN, GREEN, GREEN, GREEN, GREEN, GREEN,
    BLUE, BLUE, BLUE, BLUE, BLUE, BLUE, BLUE, BLUE
)

# QR code for donate screen - bitstream (79 bytes, 625 bits continuous)
# Bit=1 -> black ($20), Bit=0 -> white ($60)
# URL: https://bit.ly/slotshot
qr_donate_data: tuple[byte] = (
    0xFE, 0x64, 0xBF, 0xC1, 0x37, 0x90, 0x6E, 0xBC, 0xEB, 0xB7,
    0x5C, 0xC5, 0xDB, 0xA8, 0x2A, 0xEC, 0x14, 0x1D, 0x07, 0xFA,
    0xAA, 0xFE, 0x01, 0xF0, 0x00, 0xBE, 0x37, 0xBE, 0x36, 0xBD,
    0x48, 0xAE, 0xD5, 0x63, 0x77, 0x33, 0x5C, 0x1B, 0x64, 0xE6,
    0xBC, 0x8D, 0x22, 0xAA, 0xED, 0xE7, 0xF7, 0x0A, 0xE2, 0x71,
    0x9E, 0xF6, 0xFA, 0x00, 0x56, 0x46, 0x3F, 0x91, 0xAA, 0xF0,
    0x59, 0x51, 0xAB, 0xAE, 0xFF, 0xBD, 0xD6, 0x19, 0x7E, 0xEA,
    0x6A, 0x1B, 0x04, 0x23, 0xB9, 0xFE, 0x98, 0x1F, 0x80
)

# Level system
level_speeds_data: tuple[byte] = (208, 185, 161, 138, 116, 105, 94, 84, 77, 69)
cleared_thresholds_data: tuple[word] = (10, 20, 40, 60, 80, 100, 120, 140, 160, 180)

# =============================================================================
# RELOCATED DATA - Copied to target addresses at startup
# =============================================================================
# Custom charset characters - overlay ROM charset at $C800
# Each character is 8 bytes at address: $C800 + char_code * 8
# Title "SLOTSHOT" characters (top/bottom halves)
char_27: relocate[tuple[byte], 0xC8D8] = (0x00, 0x00, 0x00, 0x00, 0x3C, 0x66, 0x60, 0x38)  # S top
char_28: relocate[tuple[byte], 0xC8E0] = (0x00, 0x0C, 0x06, 0x66, 0x3C, 0x00, 0x00, 0x00)  # S bottom
char_29: relocate[tuple[byte], 0xC8E8] = (0x00, 0x00, 0x00, 0x00, 0x60, 0x60, 0x60, 0x60)  # L top
char_30: relocate[tuple[byte], 0xC8F0] = (0x00, 0x60, 0x60, 0x60, 0x7E, 0x00, 0x00, 0x00)  # L bottom
char_31: relocate[tuple[byte], 0xC8F8] = (0x00, 0x00, 0x00, 0x00, 0x3C, 0x66, 0x66, 0x66)  # O top
char_34: relocate[tuple[byte], 0xC910] = (0x00, 0x66, 0x66, 0x66, 0x3C, 0x00, 0x00, 0x00)  # O bottom
char_35: relocate[tuple[byte], 0xC918] = (0x00, 0x00, 0x00, 0x00, 0x7E, 0x18, 0x18, 0x18)  # T top
char_36: relocate[tuple[byte], 0xC920] = (0x00, 0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00)  # T bottom
char_37: relocate[tuple[byte], 0xC928] = (0x00, 0x00, 0x00, 0x00, 0x66, 0x66, 0x66, 0x7E)  # H top
char_38: relocate[tuple[byte], 0xC930] = (0x00, 0x7E, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00)  # H bottom
# "Next" indicator characters - block shape with embedded lowercase letters (XOR combination)
# Calculated: block_frame XOR letter_bitmap = letter "cutout" in filled block
# Letters shifted: "n","x" 1px right, "e","t" 1px left (to center the word visually)
char_39: relocate[tuple[byte], 0xC938] = (0x00, 0x3F, 0x48, 0x44, 0x4C, 0x4C, 0x4C, 0x7F)  # TL + "n" (shifted right)
char_40: relocate[tuple[byte], 0xC940] = (0x00, 0xFC, 0xC6, 0x9A, 0x82, 0x9E, 0xC2, 0xFE)  # TR + "e" (shifted left)
char_41: relocate[tuple[byte], 0xC948] = (0x7F, 0x4C, 0x61, 0x73, 0x61, 0x4C, 0x3F, 0x00)  # BL + "x" (shifted right)
char_42: relocate[tuple[byte], 0xC950] = (0xCE, 0x82, 0xCE, 0xCE, 0xCE, 0xE6, 0xFC, 0x00)  # BR + "t" (shifted left)
# Game block characters
char_59: relocate[tuple[byte], 0xC9D8] = (0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00)  # Progress bar
char_60: relocate[tuple[byte], 0xC9E0] = (0x00, 0x3F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F)  # Block TL
char_61: relocate[tuple[byte], 0xC9E8] = (0x00, 0xFC, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE)  # Block TR
char_62: relocate[tuple[byte], 0xC9F0] = (0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x3F, 0x00)  # Block BL
char_63: relocate[tuple[byte], 0xC9F8] = (0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFC, 0x00)  # Block BR

# Title screen character codes (bottom and top halves)
title_row0_data: tuple[byte] = (27, 29, 31, 35, 27, 37, 31, 35)
title_row1_data: tuple[byte] = (28, 30, 34, 36, 28, 38, 34, 36)

# Star positions (x, y pairs for sprites)
title_star_positions_data: tuple[word] = (
    57, 243,
    99, 219,
    249, 213,
    271, 249,
    311, 231
)
game_star_positions_data: tuple[word] = (
    57, 95,
    98, 189,
    175, 142,
    261, 201,
    283, 102
)
game_star_color_positions_data: tuple[word] = (204, 689, 459, 749, 272)

STAR_COUNT = 5

bitmap_rle: tuple[byte] = SLOTSHOT_BITMAP_RLE
screen_rle: tuple[byte] = SLOTSHOT_SCREEN_RLE
colorram_rle: tuple[byte] = SLOTSHOT_COLORRAM_RLE

# Sprite data - 64 bytes each, at $C000 in VIC Bank 3
# Same target address = consecutive placement (cannon_ready, cannon_fired, bullet, sparkle)
cannon_sprite_ready: relocate[tuple[byte], 0xC000] = (
    0xaa, 0xaa, 0x00, 0x99, 0x98, 0x00, 0x90, 0xc0,
    0x00, 0xa3, 0x00, 0x00, 0xa0, 0xc0, 0x00, 0x90,
    0x30, 0x00, 0x90, 0xc0, 0x00, 0xa3, 0x00, 0x00,
    0xa0, 0xc0, 0x00, 0x90, 0x30, 0x00, 0x90, 0xc0,
    0x00, 0xa3, 0x00, 0x00, 0xa0, 0xc0, 0x00, 0x90,
    0x30, 0x00, 0x99, 0x98, 0x00, 0xaa, 0xaa, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8c
)
cannon_sprite_fired: relocate[tuple[byte], 0xC000] = (
    0xaa, 0xaa, 0x00, 0x99, 0x98, 0x00, 0x90, 0x00,
    0x00, 0xa0, 0x00, 0x00, 0xa0, 0x00, 0x00, 0x90,
    0x00, 0x00, 0x90, 0x00, 0x00, 0xa0, 0x00, 0x00,
    0xa0, 0x00, 0x00, 0x90, 0x00, 0x00, 0x90, 0x00,
    0x00, 0xa0, 0x00, 0x00, 0xa0, 0x00, 0x00, 0x90,
    0x00, 0x00, 0x99, 0x98, 0x00, 0xaa, 0xaa, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8c
)
bullet_sprite: relocate[tuple[byte], 0xC000] = (
    0x00, 0x00, 0x00, 0x3F, 0xFC, 0x00, 0x7F, 0xFE,
    0x00, 0x7F, 0xFE, 0x00, 0x7F, 0xFE, 0x00, 0x7F,
    0xFE, 0x00, 0x7F, 0xFE, 0x00, 0x7F, 0xFE, 0x00,
    0x7F, 0xFE, 0x00, 0x7F, 0xFE, 0x00, 0x7F, 0xFE,
    0x00, 0x7F, 0xFE, 0x00, 0x7F, 0xFE, 0x00, 0x7F,
    0xFE, 0x00, 0x3F, 0xFC, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
)
sparkle_sprite: relocate[tuple[byte], 0xC000] = (
    0x00, 0x00, 0x00, 0x15, 0x54, 0x00, 0x2A, 0xA8, 0x00,
    0x55, 0x54, 0x00, 0x2A, 0xA8, 0x00, 0x55, 0x54, 0x00,
    0x2A, 0xA8, 0x00, 0x55, 0x54, 0x00, 0x2A, 0xA8, 0x00,
    0x55, 0x54, 0x00, 0x2A, 0xA8, 0x00, 0x55, 0x54, 0x00,
    0x2A, 0xA8, 0x00, 0x55, 0x54, 0x00, 0x2A, 0xA8, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00
)


# =============================================================================
# SOUND EFFECTS
# =============================================================================

# SID Channel 3 addresses
SID_CH3_FREQ = 0xD40E     # word: frequency (lo at $D40E, hi at $D40F)
SID_CH3_CTRL = 0xD412
SID_CH3_AD = 0xD413
SID_CH3_SR = 0xD414


@singleton
class _SFXInit:
    # Initialize SFX pending state (prevent spurious sound at startup)
    sfx_pending: byte[ZP_SFX_PENDING] = 0


@relocate(0xC140)
def sfx_play_fire():
    """Cannon fire sound - short sharp noise."""
    # SID registers - irq_safe because sfx_tick also writes from IRQ
    freq: word[SID_CH3_FREQ] = 0xb000
    ctrl: byte[SID_CH3_CTRL] = 0x81
    ad: byte[SID_CH3_AD] = 0x07
    sr: byte[SID_CH3_SR] = 0x20
    # State (ZP) - irq_safe because sfx_tick reads these from IRQ
    active: byte[ZP_SFX_ACTIVE] = 1
    timer: byte[ZP_SFX_TIMER] = 9
    curr_freq: word[ZP_SFX_FREQ] = 0xb000
    delta: sbyte[ZP_SFX_DELTA] = -1000


@irq_helper
@relocate(0xC140)
def _sfx_start_clear():
    """Actually start the clear sound (called from tick after delay)."""
    # SID registers (memory-mapped)
    freq: word[SID_CH3_FREQ] = 0x1000
    ctrl: byte[SID_CH3_CTRL] = 0x11
    ad: byte[SID_CH3_AD] = 0x00
    sr: byte[SID_CH3_SR] = 0xF0
    # State (ZP)
    active: byte[ZP_SFX_ACTIVE] = 3
    timer: byte[ZP_SFX_TIMER] = 4
    curr_freq: word[ZP_SFX_FREQ] = 0x1000
    delta: sbyte[ZP_SFX_DELTA] = 5
    phase: byte[ZP_SFX_PHASE] = 0
    note_len: byte[ZP_SFX_NOTE_LEN] = 2


@irq_helper
@relocate(0xC140)
def sfx_play_hit():
    """Projectile hit sound - explosion noise. IRQ-safe."""
    # SID registers (memory-mapped)
    freq: word[SID_CH3_FREQ] = 0x1500
    ctrl: byte[SID_CH3_CTRL] = 0x81
    ad: byte[SID_CH3_AD] = 0x08
    sr: byte[SID_CH3_SR] = 0x00
    # State (ZP)
    active: byte[ZP_SFX_ACTIVE] = 1
    timer: byte[ZP_SFX_TIMER] = 10
    curr_freq: word[ZP_SFX_FREQ] = 0x1500
    delta: sbyte[ZP_SFX_DELTA] = 100


@relocate(0xC140)
def sfx_play_bibip():
    """Bi-bip sound - two short beeps with gap."""
    # SID registers - irq_safe because sfx_tick also writes from IRQ
    freq: irq_safe[word[SID_CH3_FREQ]] = 0x2800
    ctrl: byte[SID_CH3_CTRL] = 0x11
    ad: byte[SID_CH3_AD] = 0x00
    sr: byte[SID_CH3_SR] = 0x80
    # State (ZP) - irq_safe because sfx_tick reads these from IRQ
    active: byte[ZP_SFX_ACTIVE] = 3
    timer: byte[ZP_SFX_TIMER] = 2
    curr_freq: irq_safe[word[ZP_SFX_FREQ]] = 0x2800
    delta: sbyte[ZP_SFX_DELTA] = 0
    phase: byte[ZP_SFX_PHASE] = 0
    note_len: byte[ZP_SFX_NOTE_LEN] = 4


@relocate(0xC140)
def sfx_play_slide():
    """Slide sound - quick 'sutty' swoosh upward."""
    # SID registers - irq_safe because sfx_tick also writes from IRQ
    freq: irq_safe[word[SID_CH3_FREQ]] = 0x2000
    ctrl: byte[SID_CH3_CTRL] = 0x81
    ad: byte[SID_CH3_AD] = 0x00
    sr: byte[SID_CH3_SR] = 0x50
    # State (ZP) - irq_safe because sfx_tick reads these from IRQ
    active: byte[ZP_SFX_ACTIVE] = 1
    timer: byte[ZP_SFX_TIMER] = 4
    curr_freq: irq_safe[word[ZP_SFX_FREQ]] = 0x2000
    delta: sbyte[ZP_SFX_DELTA] = 12


@irq_helper
def sfx_tick():
    """Called from IRQ every frame to update sound effect."""
    # SID registers (memory-mapped)
    freq: word[SID_CH3_FREQ]
    ctrl: byte[SID_CH3_CTRL]
    # State (ZP)
    active: byte[ZP_SFX_ACTIVE]
    timer: byte[ZP_SFX_TIMER]
    curr_freq: word[ZP_SFX_FREQ]
    delta: sbyte[ZP_SFX_DELTA]
    phase: byte[ZP_SFX_PHASE]
    pending: byte[ZP_SFX_PENDING]
    note_len: byte[ZP_SFX_NOTE_LEN]

    # Handle pending clear sound (delayed start)
    if pending > 0:
        pending -= 1
        if pending == 0:
            if active == 0:
                # No sound playing, start clear now
                _sfx_start_clear()
                return
            else:
                # Hit sound still playing, retry next frame
                pending = 1

    if active == 0:
        return

    # Arpeggio mode (active == 3): repeated notes with configurable length
    # note_len = note duration in frames, timer = number of notes
    if active == 3:
        phase += 1
        # Note playing phase
        if phase < note_len:
            return
        # Switch to silence at note_len
        if phase == note_len:
            ctrl = 0           # Gate off (silence)
            return
        # Silence phase (half the note length)
        if phase < note_len + note_len / 2:
            return
        # End of note cycle
        timer -= 1
        if timer == 0:
            active = 0
            return
        # Start next note with frequency change
        curr_freq += word(delta) * 256
        freq = curr_freq
        ctrl = 0x11            # Triangle + gate
        phase = 0
        return

    # Normal mode (active == 1): smooth frequency slide
    if delta >= 0:
        curr_freq += word(delta)
    else:
        curr_freq -= word(-delta)
    freq = curr_freq

    # Decrement timer
    timer -= 1
    if timer == 0:
        ctrl = 0           # Gate off
        active = 0


# =============================================================================
# IRQ HELPERS
# =============================================================================

@singleton
class _JoyInit:
    # This prevents instant fire when starting a new game after Game Over
    joy_delay: byte[ZP_JOY_DELAY] = 0


@irq_helper
def joy_handler():
    # Joystick reading and keyboard buffer injection
    joy_port: byte[JOY_PORT]           # CIA1 Port A - joystick port 2
    joy_delay: byte[ZP_JOY_DELAY]      # Repeat delay counter
    kbd_count: byte[KBD_COUNT]         # Keyboard buffer count ($C6)
    kbd_buffer: array[byte, 10][KBD_BUFFER]  # Keyboard buffer ($0277)
    key_to_inject: byte[ZP_JOY_TMP] = 0

    # --- Joystick reading (inject keys into keyboard buffer) ---

    # Read joystick port (active LOW: 0 = pressed)
    # Check directions (priority: up > down > fire)
    if (joy_port & JOY_UP_MASK) == 0:
        key_to_inject = KEY_UP
    elif (joy_port & JOY_DOWN_MASK) == 0:
        key_to_inject = KEY_DOWN
    elif (joy_port & JOY_FIRE_MASK) == 0:
        key_to_inject = KEY_SPACE

    # Apply repeat logic and inject into keyboard buffer
    if key_to_inject != 0:
        if joy_delay == 0:
            # First press or delay expired - inject key
            if kbd_count < 10:
                kbd_buffer[kbd_count] = key_to_inject
                kbd_count += 1
            joy_delay = JOY_INITIAL_DELAY
        elif joy_delay <= JOY_REPEAT_RATE:
            # In repeat mode - faster rate
            joy_delay -= 1
            if joy_delay == 0:
                if kbd_count < 10:
                    kbd_buffer[kbd_count] = key_to_inject
                    kbd_count += 1
                joy_delay = JOY_REPEAT_RATE
        else:
            # Still in initial delay
            joy_delay -= 1
    else:
        # No joystick input - reset delay for instant response next time
        joy_delay = 0


# =============================================================================
# IRQ HANDLERS
# =============================================================================

@irq
def irq_handler(vic: byte, cia1: byte):
    """Raster IRQ - updates sprite positions and reads joystick every frame."""
    raster: byte[VIC_RASTER]

    # ZP variables for sprite state (shared with main loop)
    target_y: byte[ZP_CANNON_TARGET_Y]
    current_y: byte[ZP_CANNON_CURRENT_Y]
    bullet_active: byte[ZP_BULLET_ACTIVE]
    bullet_x: word[ZP_BULLET_X]
    bullet_y: byte[ZP_BULLET_Y]
    bullet_hit_col: byte[ZP_BULLET_HIT_COL]
    sprite_en: byte[ZP_SPRITE_ENABLE]
    star_mask: byte[ZP_STAR_MASK]

    # Yellow bullet state
    bullet_type: byte[ZP_BULLET_TYPE]
    yellow_state: byte[ZP_YELLOW_STATE]
    yellow_last_empty: byte[ZP_YELLOW_LAST_EMPTY]

    # VIC sprite registers (direct access, no method calls in IRQ!)
    sprite_x0: byte[SPRITE_X]          # Sprite 0 X (cannon)
    sprite_y0: byte[SPRITE_Y]          # Sprite 0 Y (cannon)
    sprite_x1: byte[SPRITE_X + 2]      # Sprite 1 X (bullet)
    sprite_y1: byte[SPRITE_Y + 2]      # Sprite 1 Y (bullet)
    sprite_x_msb: byte[SPRITE_X_MSB]   # X bit 8 for all sprites
    sprite_enable: byte[SPRITE_ENABLE] # Sprite enable register

    # Bullet row (for collision detection)
    bullet_row: byte[ZP_BULLET_ROW]

    # Color RAM for inline collision detection
    color_ram: array[byte, 1000][COLOR]

    # Collision detection temps
    next_x: word
    screen_x: byte
    grid_col: byte
    row_base: word[ZP_BULLET_ROW_BASE]  # Cached row offset (set at fire time!)
    pos: word
    color: byte
    collision: byte
    i: byte
    block_color: byte

    # Yellow bullet scan variables
    scan_col: byte
    found_empty: byte
    target_col: byte
    scan_color: byte
    scan_pos: word

    # Sparkle effect variables (single sprite)
    sparkle_phase: byte[ZP_SPARKLE_PHASE]
    sparkle_pos: word[ZP_SPARKLE_POS]
    sprite_color: array[byte, 8][SPRITE_COLOR_0]

    # Game timer variables (ZP-mapped for main loop access)
    frame_counter: byte[ZP_FRAME_COUNTER]
    game_seconds: word[ZP_GAME_SECONDS]

    # Paused state
    paused: byte[ZP_PAUSED]

    # Only process if it's our raster IRQ (no early return - epilogue must run!)
    if (vic & 0x01) != 0:
        # Acknowledge VIC interrupt
        vic = 0x01

        if raster >= IRQ_RASTER_MUSIC and raster <= IRQ_RASTER_PLAY_AREA_BOTTOM:
            raster = IRQ_RASTER_PLAY_AREA_BOTTOM
            music_tick()
            return

        raster = IRQ_RASTER_MUSIC

        # --- Update cannon position (smooth interpolation) ---
        if current_y < target_y:
            current_y += 4
            if current_y > target_y:
                current_y = target_y
        elif current_y > target_y:
            current_y -= 4
            if current_y < target_y:
                current_y = target_y

        # Update cannon sprite Y position (sprite 0)
        sprite_y0 = current_y

        # --- Update bullet/cannon sprite 1 ---
        if bullet_active != 0:
            # PREDICTIVE COLLISION: Check BEFORE moving!
            next_x = bullet_x + BULLET_SPEED
            collision = 0

            # Check right edge first (328 = 344 - 16 visible sprite width)
            if next_x > 328:
                # Edge hit - bullet_hit_col will be set below based on bullet type
                bullet_active = 0
                collision = 1
                sfx_play_hit()
                sprite_en = sprite_en & 0xFD
                sprite_enable = sprite_en | star_mask

                # Edge reached - place block based on bullet type and state
                # NOTE: row_base is pre-calculated at fire time (avoids tuple lookup!)
                # bullet_hit_col = actual column where block is placed!

                if bullet_type == COLOR_BULLET_YELLOW:
                    # Yellow bullet: check state for placement
                    if yellow_state == YELLOW_STATE_AS_WHITE:
                        # AS_WHITE: no gap exists, place at edge (like white)
                        bullet_hit_col = GRID_WIDTH - 1
                        pos = row_base + 38  # (GRID_WIDTH - 1) * BLOCK_WIDTH = 19 * 2
                    elif yellow_last_empty < GRID_WIDTH:
                        # IN_EMPTY/BEFORE_WALL: use last empty (the gap position)
                        bullet_hit_col = yellow_last_empty
                        pos = row_base + (word(yellow_last_empty) << 1)
                    else:
                        # No empty found (0xFF) - place at edge
                        bullet_hit_col = GRID_WIDTH - 1
                        pos = row_base + 38  # (GRID_WIDTH - 1) * BLOCK_WIDTH = 19 * 2
                else:
                    # White/Blue bullet: always place at edge
                    bullet_hit_col = GRID_WIDTH - 1
                    pos = row_base + 38  # (GRID_WIDTH - 1) * BLOCK_WIDTH = 19 * 2
                # Place block with bullet's color (bullet_type IS the color!)
                color_ram[pos] = bullet_type
                color_ram[pos + 1] = bullet_type
                color_ram[pos + 40] = bullet_type
                color_ram[pos + 41] = bullet_type
            else:
                # Check block collision at NEXT position (sprite right edge = +16)
                screen_x = (next_x + 16 - SPRITE_X_OFFSET) / 8
                grid_col = screen_x >> 1

                if grid_col < GRID_WIDTH:
                    # Calculate Color RAM position (top-left of 2x2 block)
                    # NOTE: row_base is pre-calculated at fire time (avoids tuple lookup!)
                    pos = row_base + (word(grid_col) << 1)

                    # Check ALL 4 corners of the block!
                    color = (color_ram[pos] | color_ram[pos + 1] | color_ram[pos + 40] | color_ram[pos + 41]) & 0x0F

                    # === STOP AT WALL: WHITE, BLUE, or YELLOW-AS-WHITE ===
                    # All three behave the same: stop at first wall, place block before it
                    if bullet_type != COLOR_BULLET_YELLOW or yellow_state == YELLOW_STATE_AS_WHITE:
                        if color != BLACK:
                            # Block hit! bullet_hit_col set below
                            bullet_active = 0
                            collision = 1
                            sfx_play_hit()
                            sprite_en = sprite_en & 0xFD
                            sprite_enable = sprite_en | star_mask

                            if grid_col > 0:
                                # Place block with bullet's color (bullet_type IS the color!)
                                bullet_hit_col = grid_col - 1  # Block placed BEFORE collision!
                                pos = row_base + (word(grid_col - 1) << 1)
                                color_ram[pos] = bullet_type
                                color_ram[pos + 1] = bullet_type
                                color_ram[pos + 40] = bullet_type
                                color_ram[pos + 41] = bullet_type
                            else:
                                # grid_col == 0: collision in col 0, no block placed (game over!)
                                bullet_hit_col = 0

                    # === YELLOW BULLET: State machine (BEFORE_WALL, IN_WALL, IN_EMPTY) ===
                    elif yellow_state == YELLOW_STATE_BEFORE_WALL:
                        if color != BLACK:
                            # Hit first wall - switch to IN_WALL state, continue moving
                            yellow_state = YELLOW_STATE_IN_WALL
                        else:
                            # Empty space before wall - remember as potential landing spot
                            yellow_last_empty = grid_col
                    elif yellow_state == YELLOW_STATE_IN_WALL:
                        if color == BLACK:
                            # Found gap after wall! Switch to IN_EMPTY
                            yellow_state = YELLOW_STATE_IN_EMPTY
                            yellow_last_empty = grid_col
                        # else: Still in wall, continue moving
                    else:
                        # YELLOW_STATE_IN_EMPTY - in gap, looking for end
                        if color != BLACK:
                            # Wall after gap - STOP and place block at last empty!
                            bullet_hit_col = yellow_last_empty  # Block placed at gap position!
                            bullet_active = 0
                            collision = 1
                            sfx_play_hit()
                            sprite_en = sprite_en & 0xFD
                            sprite_enable = sprite_en | star_mask

                            # Place block at last empty position (bullet_type IS the color!)
                            if yellow_last_empty < GRID_WIDTH:
                                pos = row_base + (word(yellow_last_empty) << 1)
                                color_ram[pos] = bullet_type
                                color_ram[pos + 1] = bullet_type
                                color_ram[pos + 40] = bullet_type
                                color_ram[pos + 41] = bullet_type
                        else:
                            # Still in gap - update last empty position
                            yellow_last_empty = grid_col

            # Only move and update sprite if no collision
            if collision == 0:
                bullet_x = next_x
                sprite_x1 = bullet_x & 0xFF
                sprite_y1 = bullet_y

                # Update X MSB (bit 1 for sprite 1)
                if bullet_x > 255:
                    sprite_x_msb = sprite_x_msb | 0x02
                else:
                    sprite_x_msb = sprite_x_msb & 0xFD
        else:
            # Bullet not active - sprite 1 follows cannon (loaded inside barrel)
            # BUT: Don't move sprite back if collision just happened (bullet_hit_col != 255)
            # This prevents the "flash back to cannon" glitch before main loop hides the sprite
            if bullet_hit_col == 255:
                sprite_x1 = CANNON_SPRITE_X
                sprite_y1 = current_y
                sprite_x_msb = sprite_x_msb & 0xFD  # Clear bit 1 (X < 256)

        # --- Sparkle effect update ---
        # Update sparkle sprite 2 - color fade
        if sparkle_phase != 0:
            # Check if the block is still there (not removed by bullet/cascade)
            color = color_ram[sparkle_pos] & 0x0F
            if color == BLACK:
                # Block disappeared - cancel sparkle immediately
                sparkle_phase = 0
                sprite_en = sprite_en & 0xFB  # Clear bit 2
                sprite_enable = sprite_en | star_mask
            else:
                # Block still there - continue animation
                # Color fade based on phase (1=dark, 2=light peak, 3=dark)
                if sparkle_phase == 2:
                    sprite_color[2] = COLOR_SPARKLE_2  # Light peak
                else:
                    sprite_color[2] = COLOR_SPARKLE_1  # Dark (phase 1 or 3)
                # Advance phase
                sparkle_phase += 1
                if sparkle_phase > SPARKLE_PHASE_MAX:
                    # Animation complete - disable sprite 2
                    sparkle_phase = 0
                    sprite_en = sprite_en & 0xFB  # Clear bit 2
                    sprite_enable = sprite_en | star_mask

        return

    # --- CIA1 Timer A (always 60 Hz, platform independent!) ---
    # Play sound effects
    sfx_tick()

    # --- Game timer update ---
    frame_counter += 1
    if frame_counter >= 60 and not paused:
        frame_counter = 0
        game_seconds += 1

    # --- Update star visibility based on Color RAM ---
    star_mask = 0xF8  # Start with all stars enabled
    for i in range(5):
        pos = game_star_color_positions_data[i]
        if (color_ram[pos] & 0x0F) != BLACK:
            star_mask = star_mask & (0xFF ^ byte(1 << (3 + i)))
    sprite_enable = sprite_en | star_mask

    joy_handler()

    # Epilogue runs here - chains to system IRQ (keyboard, jiffy clock)


@irq
def irq_title_handler(vic: byte, cia1: byte):
    """Split screen IRQ for title screen - raster-based bitmap/text mode switching."""
    # VIC registers
    raster: byte[VIC_RASTER]
    vic_ctrl1: byte[VIC_CTRL1]
    vic_ctrl2: byte[VIC_CTRL2]
    vic_memptr: byte[VIC_MEMPTR]

    # Handle VIC raster interrupt
    if vic & 0x01:
        # Acknowledge VIC interrupt
        vic = 0x01

        # ZONE 3: At text switch line (>= TITLE_RASTER_TO_TEXT)
        # Switch to TEXT mode - highest priority for fixed timing
        if raster >= TITLE_RASTER_TO_TEXT:
            # Next interrupt: top of screen
            raster = TITLE_RASTER_TO_BITMAP
            # Re-enable CIA1 interrupts
            cia1 = 0x81
            # Switch to text mode - stabilizer row hides any glitch
            vic_memptr = TITLE_MEMPTR_TEXT
            vic_ctrl1 = (vic_ctrl1 & 0x7F) & (0xFF ^ TITLE_VIC_BITMAP_MODE)
            vic_ctrl2 = vic_ctrl2 & (0xFF ^ TITLE_VIC_MULTICOLOR)

        # ZONE 2: Before switch line (>= TITLE_RASTER_BEFORE_SWITCH)
        # Disable CIA1 for precise timing
        elif raster >= TITLE_RASTER_BEFORE_SWITCH:
            # Next interrupt: at the mode switch line
            raster = TITLE_RASTER_TO_TEXT
            cia1 = 0x7F  # Disable CIA1 interrupts

        # ZONE 1: Top of screen (< TITLE_RASTER_BEFORE_SWITCH)
        # Switch to BITMAP mode
        else:
            # Next interrupt: before the mode switch
            raster = TITLE_RASTER_BEFORE_SWITCH
            vic_memptr = TITLE_MEMPTR_BITMAP
            vic_ctrl1 = ((vic_ctrl1 & 0x7F) | TITLE_VIC_BITMAP_MODE) & (0xFF ^ TITLE_VIC_ECM_MODE)
            vic_ctrl2 = vic_ctrl2 | TITLE_VIC_MULTICOLOR
            # Re-enable CIA1 interrupts
            cia1 = 0x81
            # From here we have enough time for a music tick
            music_tick()

        # Do not process epilogue
        return

    # --- CIA1 Timer A (always 60 Hz, platform independent!) ---
    # --- Joystick reading (inject keys into keyboard buffer) ---
    joy_handler()

    # Epilogue runs here - chains to system IRQ (keyboard, jiffy clock)


@irq
@relocate(0xC140)
def irq_screen_handler(vic: byte, cia1: byte):
    """Screen IRQ handler."""
    if vic & 0x01:
        # Acknowledge VIC interrupt
        vic = 0x01
        # Play music
        music_tick()
        return

    # --- Joystick reading (inject keys into keyboard buffer) ---
    joy_handler()
    # Epilogue runs here - chains to system IRQ (keyboard, jiffy clock)


# =============================================================================
# SCREEN CLASS - Hardware access (Color RAM only optimization)
# =============================================================================

@singleton
class Screen:
    """ Screen class for hardware access """
    screen: array[byte, 1000][SCREEN] = [0]
    colors: array[byte, 1000][COLOR] = [COLOR_BLACK]
    border: byte[BORDER]
    background: byte[BACKGROUND]
    # ECM background colors
    bg1: byte[VIC_BG1] = COLOR_TITLE_BG      # Title bar background (blue)
    bg2: byte[VIC_BG2] = COLOR_STATUS_BG     # Status bar background (dark grey)
    bg3: byte[VIC_BG3] = COLOR_HIGHLIGHT_BG   # Highlight background (for level flash)
    raster: byte[VIC_RASTER]
    vic_ctrl1: byte[VIC_CTRL1]
    vic_ctrl2: byte[VIC_CTRL2]
    vic_memptr: byte[VIC_MEMPTR]

    # CIA2 registers
    cia2_pra: byte[CIA2_PRA]

    # Sprite registers
    sprite_x: array[byte, 16][SPRITE_X]
    sprite_x_msb: byte[SPRITE_X_MSB]
    sprite_enable: byte[SPRITE_ENABLE]
    sprite_expand_x: byte[SPRITE_EXPAND_X]
    sprite_expand_y: byte[SPRITE_EXPAND_Y]
    sprite_priority: byte[SPRITE_PRIORITY]
    sprite_multicolor: byte[SPRITE_MULTICOLOR]
    sprite_mc1: byte[SPRITE_MC1]    # Multicolor 1 (shared by all sprites)
    sprite_mc2: byte[SPRITE_MC2]    # Multicolor 2 (shared by all sprites)
    sprite_color: array[byte, 8][SPRITE_COLOR_0]
    sprite_ptr: array[byte, 8][SPRITE_POINTER_BASE]

    def init_play_area():
        """
        Fill play area with block characters - colors determine visibility.
        BLACK color = invisible block, any other color = visible block.
        """
        pos: word
        screen_y: byte
        x: byte
        y: byte

        # Iterate over block rows (10 blocks = 20 screen rows)
        for y in range(GRID_HEIGHT):
            screen_y = PLAY_TOP + y * BLOCK_HEIGHT
            pos = row_offset_data[screen_y]
            for x in range(GRID_WIDTH):
                self.colors[pos] = BLACK
                self.screen[pos] = CHAR_BLOCK_TL
                self.colors[pos + 1] = BLACK
                self.screen[pos + 1] = CHAR_BLOCK_TR
                self.colors[pos + 40] = BLACK
                self.screen[pos + 40] = CHAR_BLOCK_BL
                self.colors[pos + 41] = BLACK
                self.screen[pos + 41] = CHAR_BLOCK_BR
                # Colors already BLACK from array init = invisible blocks
                pos += BLOCK_WIDTH

    def sync_raster(raster: byte):
        vic_ctrl: byte[VIC_CTRL1]
        while self.raster > raster or (vic_ctrl & 0x80) != 0:
            pass
        while self.raster < raster and (vic_ctrl & 0x80) == 0:
            pass

    def wait_frames(count: byte):
        """Wait for multiple frames."""
        vic_ctrl: byte[VIC_CTRL1]
        for _ in range(count):
            # Wait for lower border
            while self.raster < IRQ_RASTER_PLAY_AREA_BOTTOM and (vic_ctrl & 0x80) == 0:
                pass
            # Wait for raster 256+ (bit 8 set in $D011)
            while (vic_ctrl & 0x80) == 0:
                pass
            while self.raster < 10 or (vic_ctrl & 0x80) != 0:
                pass

    def set_game_mode():
        # Set background and border colors
        __sei__()
        self.background = COLOR_SCREEN_BG
        # Configure VIC for ECM text mode (game)
        self.vic_memptr = GAME_MEMPTR
        # ECM ON (bit 6), DEN ON (bit 4), Bitmap OFF (bit 5), preserve raster MSB (bit 7 masked)
        self.vic_ctrl1 = (self.vic_ctrl1 & 0x9F) | TITLE_VIC_ECM_MODE | VIC_DEN
        # Multicolor OFF
        self.vic_ctrl2 = self.vic_ctrl2 & (0xFF ^ TITLE_VIC_MULTICOLOR)
        # Bank 3 ($C000-$FFFF)
        self.cia2_pra = self.cia2_pra & 0xFC  # Bank 3 ($C000-$FFFF)
        __cli__()

    def set_bitmap_mode():
        """Configure VIC for multicolor bitmap mode (title screen)."""
        __sei__()
        # Set background and border colors
        self.border = SLOTSHOT_BGCOLOR
        self.background = SLOTSHOT_BGCOLOR
        # The IRQ will switch to the bitmap mode
        # Bank 3 ($C000-$FFFF)
        self.cia2_pra = self.cia2_pra & 0xFC  # Bank 3 ($C000-$FFFF)
        __cli__()

    def print_at(x: byte, y: byte, text: alias[string], col: byte, bg: byte):
        """Print text with ECM background select (bg = BG_PLAY/BG_TITLE/BG_STATUS/BG_HIGHLIGHT)."""
        pos: word
        i: byte
        code: byte

        pos = row_offset_data[y] + x
        for i in range(len(text)):
            code = text[i]
            if code >= 65 and code <= 90:
                code -= 64
            elif code >= 97 and code <= 122:
                code -= 96
            elif code >= 48 and code <= 57:
                pass
            # Add ECM background offset to character code
            self.screen[pos] = code + bg
            self.colors[pos] = col
            pos += 1

    def print_center_at_offset(y: byte, text: alias[string], col: byte, bg: byte, offset: sbyte):
        """Print text centered at the given y position with an offset."""
        self.print_at(20 - len(text) / 2 + offset, y, text, col, bg)

    def print_center(y: byte, text: alias[string], col: byte, bg: byte):
        """Print text centered at the given y position."""
        self.print_at(20 - len(text) / 2, y, text, col, bg)

    def print_number(x: byte, y: byte, num: word, digits: byte, col: byte, bg: byte):
        """Print number with ECM background select."""
        pos: word
        temp: word
        i: byte

        pos = row_offset_data[y] + x + digits - 1
        temp = num

        for i in range(digits):
            self.screen[pos] = 48 + (temp % 10) + bg
            self.colors[pos] = col
            temp = temp / 10
            pos -= 1

    def draw_progress_bar(filled: byte):
        """
        Draw progress bar with Commodore rainbow colors.
        filled = number of characters to show (0-40), depletes from right to left.
        Depleted segments show dark grey line instead of disappearing.
        """
        pos: word = PROGRESS_BAR_ROW * 40 + PROGRESS_BAR_START
        i: byte
        ecm_char: byte

        # ECM character code - always use progress bar character
        ecm_char = CHAR_PROGRESS + BG_STATUS

        # Draw the progress bar (rainbow on left, dark grey on right)
        for i in range(PROGRESS_BAR_WIDTH):
            self.screen[pos] = ecm_char
            if i < filled:
                # Active segment - rainbow color
                self.colors[pos] = commodore_rainbow_data[i]
            else:
                # Depleted segment - grey line remains visible on dark grey bg
                self.colors[pos] = GREY
            pos += 1


# =============================================================================
# SPRITE DATA SINGLETON
# =============================================================================

@singleton
class Sprites:
    """Sprite data storage and initialization."""
    # Star sprite needs runtime generation (simple dot pattern)
    # Other sprites (cannon, bullet, sparkle) handled by relocate tuples at $C000
    star_data: array[byte, 64][SPRITE_DATA_ADDR + 256] = [0]

    def __init__():
        """Initialize star sprite - other sprites already at target via relocate."""
        # Generate star sprite: 2x1 pixel dot in top-left
        self.star_data[0] = 0xC0  # %11000000 = leftmost 2 pixels

    def init_stars(positions: tuple[word], color: byte):
        """Initialize star sprites (sprites 3-7)."""
        i: byte
        x: word

        # Clear star sprite MSB bits (3-7)
        Screen.sprite_x_msb = Screen.sprite_x_msb & 0x07

        # Setup each star sprite
        for i in range(STAR_COUNT):
            x = positions[i * 2]
            Screen.sprite_x[6 + i * 2] = x & 0xFF
            Screen.sprite_x[7 + i * 2] = positions[i * 2 + 1]
            Screen.sprite_ptr[3 + i] = STAR_BLOCK
            Screen.sprite_color[3 + i] = color
            if x > 255:
                Screen.sprite_x_msb = Screen.sprite_x_msb | byte(1 << (3 + i))

        # Stars are hires (not multicolor)
        Screen.sprite_multicolor = Screen.sprite_multicolor & 0x07
        Screen.sprite_enable = Screen.sprite_enable | 0xF8


# =============================================================================
# RANDOM NUMBER GENERATOR (Multi-step Galois LFSR)
# =============================================================================

@singleton
class Random:
    """
    16-bit Galois LFSR + Weyl sequence for streak-free randomness.

    The LFSR alone produces correlated consecutive values (causing streaks).
    The Weyl sequence (adding an odd constant each step) breaks this correlation
    because LFSR + Weyl creates unpredictable jumps across the full range.

    The add+xor mixing diffuses bits better than pure XOR.
    Period: 65535 (LFSR) × 65536 (Weyl) = effectively unlimited for games.
    """
    state: word[RANDOM_STATE_ADDR]
    state_lo: byte[RANDOM_STATE_ADDR]      # Direct access to low byte
    state_hi: byte[RANDOM_STATE_ADDR + 1]  # Direct access to high byte
    weyl: word[RANDOM_WEYL_ADDR]           # Weyl sequence (breaks LFSR linearity)
    weyl_lo: byte[RANDOM_WEYL_ADDR]        # Direct access for mixing
    weyl_hi: byte[RANDOM_WEYL_ADDR + 1]    # Direct access for mixing
    cia1_timer: word[CIA1_TA_LO]           # CIA1 Timer A (~1MHz, fast entropy)
    raster: byte[VIC_RASTER]               # VIC-II raster (~15kHz, independent HW!)

    def __init__():
        """Seed from CIA timer (fast) + VIC raster (independent hardware)."""
        # word(byte) << 8 is now optimized by compiler (no shift loop!)
        # LFSR must never be 0, Weyl should be odd
        self.state = (self.cia1_timer ^ (word(self.raster) << 8)) | 0x0001
        self.weyl = (self.cia1_timer + word(self.raster)) | 0x0001

    def next() -> byte:
        """One step with LFSR + Weyl mixing. Returns streak-free 8-bit value."""
        # 16-bit Galois LFSR: polynomial x^16 + x^14 + x^13 + x^11 + 1
        if self.state & 1:
            self.state = (self.state >> 1) ^ 0xB400
        else:
            self.state = self.state >> 1
        # Weyl sequence: add odd constant (0x61C8) - breaks LFSR linearity!
        self.weyl = self.weyl + 0x61C9
        # Add+XOR mixing: better diffusion than pure XOR
        # Cross-combines LFSR and Weyl bytes for maximum decorrelation
        return (self.state_hi + self.weyl_lo) ^ (self.state_lo + self.weyl_hi)

    def range(max_val: byte) -> byte:
        """Unbiased range mapping using multiplication. Returns 0 to max_val-1."""
        # floor(next * max / 256) - avoids modulo bias!
        return byte(word(self.next()) * max_val >> 8)

    def range_mask(mask: byte) -> byte:
        """FAST! Use for power-of-2 ranges: range_mask(0x1F) = 0-31"""
        return self.next() & mask


# =============================================================================
# HIGH SCORE SINGLETON
# =============================================================================

@singleton
class HighScore:
    """ Store the high score value. """
    score: word = 0


# =============================================================================
# GRID CLASS - Block management (Color RAM only)
# =============================================================================

class XY:
    """Screen coordinates for dying blocks. x=screen column (0-38), y=screen row (0-24)."""
    x: byte
    y: byte


class Grid:
    """
    Block management
    Color RAM is the single source of truth.
    """
    # Pre-generated column patterns (11 bytes each: 1 count + 10 colors)
    column_pool: array[byte, COLUMN_POOL_SIZE * COLUMN_ENTRY_SIZE][COLUMN_POOL_ADDR]

    # Block count per column (1-19, index 0 = column 1)
    # Updated on: spawn, bullet hit, shift, cascade
    col_count: array[byte, 19] = 0

    # Dying blocks animation - stores screen XY of blocks that will fade out
    # Max 40 blocks (4 columns * 10 rows = worst case in one scroll cycle)
    dying_positions: array[XY, 40]
    dying_count: byte = 0

    def __init__():
        """Pre-generate column patterns at startup."""
        col: byte
        row: byte
        holes: byte
        h: byte
        hole_pos: byte
        color: byte
        block_count: byte
        offset: word = 0
        ro: word
        pos: word

        for col in range(COLUMN_POOL_SIZE):
            # Skip first byte (will store count later)
            ro = offset + 1

            # Fill column with random colors (FAST bitmask - no modulo!)
            for row in range(GRID_HEIGHT):
                color = block_colors_data[Random.range_mask(BLOCK_COLORS_MASK)]
                self.column_pool[ro] = color
                ro += 1

            # Add 1-4 random holes AND count blocks in one pass
            # Start with full count, decrement only when creating NEW hole (handles overlaps!)
            holes = Random.range_mask(MAX_HOLES_MASK) + 1
            block_count = GRID_HEIGHT
            for h in range(holes):
                hole_pos = Random.range(GRID_HEIGHT)  # 10 = not power-of-2, use modulo
                pos = offset + 1 + word(hole_pos)
                if self.column_pool[pos] != BLACK:  # Only count if not already a hole
                    self.column_pool[pos] = BLACK
                    block_count -= 1
            self.column_pool[offset] = block_count

            offset += COLUMN_ENTRY_SIZE

    def get_color(col: byte, row: byte) -> byte:
        """
        Get block color from Color RAM (BLACK = empty).
        NOTE: Color RAM is 4-bit only! Upper 4 bits are garbage on read!
        """
        return Screen.colors[row_offset_data[PLAY_TOP + row * BLOCK_HEIGHT] + (col * BLOCK_WIDTH)] & 0x0F

    def shift_col_count_left():
        """Shift col_count array LEFT by 1 (columns scroll left, count follows)."""
        i: byte
        for i in range(18):
            self.col_count[i] = self.col_count[i + 1]
        self.col_count[18] = 0  # Rightmost becomes empty, spawn_column() will set it

    def spawn_column():
        """
        Pick random column from pool and blit directly to Color RAM.
        Uses 4 blkcpy calls with dual-stride for 2x2 block expansion.
        Also updates Game.col_count[18] with pre-calculated block count.
        """
        pool_offset: word
        offset: word

        # Pick random column from pool (unbiased multiplication-based range)
        pool_offset = word(Random.range(COLUMN_POOL_SIZE)) * COLUMN_ENTRY_SIZE

        # Read pre-calculated block count and store for rightmost column (index 18)
        self.col_count[18] = self.column_pool[pool_offset]

        # Calculate Color RAM offset for rightmost column (chars 38-39)
        offset = row_offset_data[PLAY_TOP] + 38

        # 4 blkcpy calls to fill 2x2 blocks:
        # src_stride=1 (pool bytes are consecutive)
        # dst_stride=80 (2 screen rows = 80 bytes between blocks)
        # width=1, height=10 (10 blocks)
        # NOTE: pool_offset + 1 skips the count byte

        # Top-left corner of each block
        blkcpy(self.column_pool, pool_offset + 1, 1, Screen.colors, offset, 80, 1, 10)
        # Top-right corner
        blkcpy(self.column_pool, pool_offset + 1, 1, Screen.colors, offset + 1, 80, 1, 10)
        # Bottom-left corner (+40 = next screen row)
        blkcpy(self.column_pool, pool_offset + 1, 1, Screen.colors, offset + 40, 80, 1, 10)
        # Bottom-right corner
        blkcpy(self.column_pool, pool_offset + 1, 1, Screen.colors, offset + 41, 80, 1, 10)

    def age_player_blocks():
        """
        Age player-placed blocks: WHITE → LIGHT_GREY → GREY → DARK_GREY.
        DARK_GREY blocks are added to dying list for flash animation.
        Called once per scroll, so blocks disappear after 4 scrolls.
        """
        # Aging lookup: index=color, value=next color (0=skip)
        aging: tuple[byte] = (0, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 11, 0, 0, 12)
        base_pos: word
        pos: word
        color: byte
        row: byte
        col: byte
        xy: alias[XY]

        # Reset dying list at start of each age cycle
        self.dying_count = 0

        # Iterate over all grid cells (only top-left corner of each 2x2 block)
        for row in range(GRID_HEIGHT):
            base_pos = row_offset_data[PLAY_TOP + row * BLOCK_HEIGHT]
            for col in range(GRID_WIDTH):
                pos = base_pos + word(col) * BLOCK_WIDTH
                color = Screen.colors[pos] & 0x0F

                # DARK_GREY → dying animation (special case)
                if color == DARK_GREY:
                    if self.dying_count < 40:
                        alias(xy, addr(self.dying_positions[self.dying_count]))
                        xy.x = byte(col * BLOCK_WIDTH)
                        xy.y = byte(PLAY_TOP + row * BLOCK_HEIGHT)
                        self.dying_count += 1
                    continue

                # Lookup next color (0 = not a player block, skip)
                color = aging[color]
                if color == 0:
                    continue

                # Update all 4 cells of the 2x2 block
                Screen.colors[pos] = color
                Screen.colors[pos + 1] = color
                Screen.colors[pos + 40] = color
                Screen.colors[pos + 41] = color

    def is_column_complete(col: byte) -> bool:
        """Check if column is complete (all rows have blocks) - O(1) using col_count."""
        # Column 0 is cannon, never complete
        if col == 0:
            return False
        return self.col_count[col - 1] == GRID_HEIGHT

    def has_block(col: byte) -> bool:
        """Check if column has a block."""
        row: byte
        for row in range(GRID_HEIGHT):
            if self.get_color(col, row):
                return True
        return False

    def shift_columns_right(col: byte):
        """
        Shift columns 0..(col-1) one position to the RIGHT, overwriting column 'col'.
        This "pushes back" the blocks, giving the player more space!
        Also updates col_count array to match shifted columns.
        NOTE: Flash effect is handled by Game.update_effect() state machine.
        """
        c: byte
        src_offset: word
        dst_offset: word

        # Shift columns RIGHT: copy from col-1 down to 0
        # Each iteration: copy column c to column c+1
        # Must process RIGHT to LEFT - blkcpy backward only works per-row, not per-column!
        for c in range(col - 1, -1, -1):
            src_offset = row_offset_data[PLAY_TOP] + word(c) * BLOCK_WIDTH
            dst_offset = src_offset + BLOCK_WIDTH
            blkcpy(Screen.screen, src_offset, Screen.screen, dst_offset, BLOCK_WIDTH, PLAY_ROWS, SCREEN_WIDTH)
            blkcpy(Screen.colors, src_offset, Screen.colors, dst_offset, BLOCK_WIDTH, PLAY_ROWS, SCREEN_WIDTH)

        # Shift col_count array right to match: columns 1..col-1 → 2..col
        # col_count index = column - 1 (so column 1 = index 0)
        # Must process right to left to avoid overwriting source values
        for c in range(col - 1, 0, -1):
            self.col_count[c] = self.col_count[c - 1]
        self.col_count[0] = 0  # Column 1 is now empty (cannon col has no blocks)


# =============================================================================
# GAME CLASS - Main game logic (IRQ-based sprites)
# =============================================================================

class Game:
    """
    Main game logic
    """
    grid: Grid

    score: word = INITIAL_SCORE
    level: byte = 1
    cols_cleared: word = 0  # Total columns cleared
    active_col_count: byte = 0  # Number of columns with blocks (for slide sound)

    move_timer: word = 0
    last_jiffy: byte = 0      # Last jiffy_lo value for delta timing (60 Hz)
    column_speed: word = 250  # CIA1 ticks between column movements (60 Hz, platform independent)

    running: bool = True
    game_over: bool = False
    paused: bool[ZP_PAUSED] = False

    music_enabled: bool = False

    # Effect state machine (non-blocking column clear animation)
    effect_phase: byte = 0       # 0=idle, 1-7=flash phases
    effect_frame: byte = 0       # Frame counter within current phase
    effect_col: byte = 0         # Column being animated
    effect_saved_colors: array[byte, GRID_HEIGHT]  # Saved original colors
    effect_from_cascade: bool = False  # True if column clear was triggered by cascade

    # Cascade state machine (horizontal slide effect)
    cascade_phase: byte = 0       # Current state (CASCADE_IDLE, CASCADE_SCAN, etc.)
    cascade_frame: byte = 0       # Frame counter within current state
    cascade_row: byte = 0         # Row being cascaded (0-9)
    cascade_src_col: byte = 0     # Source column (leftmost block to slide)
    cascade_dst_col: byte = 0     # Destination column (rightmost empty)
    cascade_scan_row: byte = 0    # Current scan position
    cascade_max_col: byte = 0     # Maximum column to search (= effect_col, blocks right of this don't cascade)

    # Dying blocks animation (flash before disappearing)
    # Animation: DARK_GREY → GREY → LIGHT_GREY → WHITE → BLACK (gone!)
    dying_phase: byte = 0         # 0=idle, 1-4=animation phases
    dying_frame: byte = 0         # Frame counter within current phase
    scroll_pending: bool = False  # Scroll waiting for dying animation to finish
    level_flash: byte = 0         # Level-up flash counter (10=5 flashes, counts down)

    # High score display alternation
    score_display_timer: word = 0        # Frame counter for alternation
    showing_high_score: bool = False     # True = show high score, False = show current score
    high_score_beaten: bool = False      # True = already beat high score this game (for sound)

    # ZP variable mappings for IRQ communication
    cannon_row_zp: byte[ZP_CANNON_ROW]
    cannon_target_zp: byte[ZP_CANNON_TARGET_Y]
    cannon_current_zp: byte[ZP_CANNON_CURRENT_Y]
    bullet_active_zp: byte[ZP_BULLET_ACTIVE]
    bullet_x_zp: irq_safe[word[ZP_BULLET_X]]
    bullet_y_zp: byte[ZP_BULLET_Y]
    bullet_hit_col_zp: byte[ZP_BULLET_HIT_COL]
    bullet_row_zp: byte[ZP_BULLET_ROW]  # Grid row at firing time (fixed!)
    bullet_row_base_zp: word[ZP_BULLET_ROW_BASE]  # Row offset (cached for IRQ!)
    sprite_en_zp: byte[ZP_SPRITE_ENABLE]
    star_mask_zp: byte[ZP_STAR_MASK]

    # Yellow bullet ZP mappings
    bullet_type_zp: byte[ZP_BULLET_TYPE]
    next_bullet_type_zp: byte[ZP_NEXT_BULLET_TYPE]
    yellow_state_zp: byte[ZP_YELLOW_STATE]
    yellow_last_empty_zp: byte[ZP_YELLOW_LAST_EMPTY]

    # Enable key repeat for all keys
    rptflg: byte[KERNAL_RPTFLG] = 0x80

    def draw_next_indicator():
        """Draw the 2x2 'Next' indicator block at columns 0-1, rows 23-24."""
        next_type: byte[ZP_NEXT_BULLET_TYPE]
        bg_color: byte = BG_STATUS

        # Special background highlight for blue bullet
        if next_type == COLOR_BULLET_BLUE:
            bg_color = BG_HIGHLIGHT

        # Draw 2x2 block with "next" characters (ECM background 2 = status bar)
        # next_type IS the color - no conversion needed!
        Screen.screen[40 * 23 + 2] = CHAR_NEXT_TL + bg_color
        Screen.colors[40 * 23 + 2] = next_type
        Screen.screen[40 * 23 + 3] = CHAR_NEXT_TR + bg_color
        Screen.colors[40 * 23 + 3] = next_type
        Screen.screen[40 * 24 + 2] = CHAR_NEXT_BL + bg_color
        Screen.colors[40 * 24 + 2] = next_type
        Screen.screen[40 * 24 + 3] = CHAR_NEXT_BR + bg_color
        Screen.colors[40 * 24 + 3] = next_type

    def determine_next_bullet():
        """Randomly determine the next bullet type (which IS the color!)."""
        next_type: byte[ZP_NEXT_BULLET_TYPE]
        rnd: byte

        rnd = Random.next()
        if rnd < YELLOW_CHANCE_THRESHOLD:
            next_type = COLOR_BULLET_YELLOW
        elif rnd < BLUE_CHANCE_THRESHOLD:
            next_type = COLOR_BULLET_BLUE
        else:
            next_type = COLOR_BULLET

        self.draw_next_indicator()

    def draw_title():
        """Draw title bar (rows 0-1) with ECM background and half-characters."""
        screen_title: array[byte, 80][SCREEN] = [CHAR_SPACE + BG_TITLE]
        x: byte
        color: byte

        # Draw "SLOTSHOT" using half-characters (8 letters, centered at column 16)
        # Row 0: bottom halves (these appear at top of title bar)
        # Row 1: top halves (these appear at bottom of title bar)
        for x in range(8):
            Screen.screen[16 + x] = title_row0_data[x] + BG_TITLE
            Screen.screen[16 + 40 + x] = title_row1_data[x] + BG_TITLE
            # Apply gradient: every 2 characters change color
            if x < 4:
                color = WHITE
            else:
                color = LIGHT_GREY
            Screen.colors[16 + x] = color
            Screen.colors[16 + 40 + x] = color

    def update_status():
        """Update status bar"""
        score_color: byte
        label_color: byte
        display_value: word
        best: bool = False

        Screen.print_number(15, 23, self.cols_cleared, 5, COLOR_STATUS_TEXT_HIGHLIGHT, BG_STATUS)
        if self.level_flash == 0:
            Screen.print_number(27, 23, word(self.level), 2, COLOR_STATUS_TEXT_HIGHLIGHT, BG_STATUS)

        # Show "H-" prefix and high score, or current score
        # When game is over, always show player's score (not alternating high score)
        if self.showing_high_score and HighScore.score > 0 and not self.game_over:
            Screen.print_at(6, 24, " H-", COLOR_HIGH_SCORE_LABEL, BG_STATUS)
            display_value = HighScore.score
            label_color = COLOR_HIGH_SCORE_LABEL
            score_color = COLOR_HIGH_SCORE
        else:
            label_color = COLOR_STATUS_TEXT
            score_color = COLOR_STATUS_TEXT_HIGHLIGHT
            display_value = self.score
            # Highlight if beating high score
            if HighScore.score and HighScore.score < self.score:
                # Play sound once when first beating high score
                if not self.high_score_beaten:
                    self.high_score_beaten = True
                    sfx_play_bibip()
                Screen.print_at(6, 24, "NEW BEST", COLOR_STATUS_TEXT, BG_STATUS)
                best = True
            else:
                Screen.print_at(7, 24, "  ", COLOR_STATUS_TEXT, BG_STATUS)

        if not best:
            Screen.print_at(9, 24, "SCORE:", label_color, BG_STATUS)
        Screen.print_number(15, 24, display_value, 5, score_color, BG_STATUS)

    def update_score_display():
        """Handle alternating score/high score display (call every frame)."""
        self.score_display_timer += 1
        if self.score_display_timer >= SCORE_DISPLAY_TOGGLE_FRAMES:
            self.score_display_timer = 0
            self.showing_high_score = not self.showing_high_score
            self.update_status()  # Refresh display on toggle

    def update_level_flash():
        """Animate level number flashing on level-up (inverse effect)."""
        phase: byte
        color: byte
        if self.level_flash == 0:
            return
        # Slow down: only update every 8 frames (level_flash counts 80→0)
        phase = self.level_flash / 8  # 0-9 → 5 full cycles
        # Odd phase = inverse (white bg + dark text), even = normal
        if phase & 1:
            color = DARK_GREY
        else:
            color = COLOR_STATUS_TEXT_HIGHLIGHT
        Screen.print_number(27, 23, word(self.level), 2, color, BG_STATUS)
        self.level_flash -= 1

    def update_time():
        """Update elapsed time display on status bar."""
        # Uses IRQ-based game_seconds counter (immune to jiffy clock overflow)
        game_seconds: word[ZP_GAME_SECONDS]
        minutes: byte
        secs: byte
        # Calculate minutes and seconds from IRQ counter
        minutes = game_seconds / 60
        secs = game_seconds % 60

        Screen.print_number(27, 24, minutes, 2, COLOR_STATUS_TEXT_HIGHLIGHT, BG_STATUS)
        Screen.print_number(30, 24, secs, 2, COLOR_STATUS_TEXT_HIGHLIGHT, BG_STATUS)

    def draw_pause():
        """Highlight PAUSE text in status bar."""
        bg_color: byte
        fg_color: byte
        fg_color_text: byte
        if self.paused:
            bg_color = BG_HIGHLIGHT
            fg_color = COLOR_STATUS_SHORTCUTS_HIGHLIGHT
            fg_color_text = COLOR_STATUS_TEXT_HIGHLIGHT
        else:
            bg_color = BG_STATUS
            fg_color = COLOR_STATUS_SHORTCUTS
            fg_color_text = COLOR_STATUS_TEXT
        Screen.print_at(35, 23, "P", fg_color, bg_color)
        Screen.print_at(36, 23, "AUSE", fg_color_text, BG_STATUS)

    def draw_status():
        """Draw status bar (rows 22-24) with ECM background."""
        x: byte
        pos: word
        screen_status: array[byte, 80][SCREEN + 40 * 23] = [CHAR_SPACE + BG_STATUS]

        Screen.print_at(7, 23, "CLEARED:", COLOR_STATUS_TEXT, BG_STATUS)
        Screen.print_at(9, 24, "SCORE:", COLOR_STATUS_TEXT, BG_STATUS)
        Screen.print_at(21, 23, "LEVEL:", COLOR_STATUS_TEXT, BG_STATUS)
        Screen.print_at(22, 24, "TIME:", COLOR_STATUS_TEXT, BG_STATUS)
        Screen.print_at(29, 24, ":", COLOR_STATUS_TEXT_HIGHLIGHT, BG_STATUS)

        # Draw "Next" indicator (2x2 block at columns 0-1, rows 23-24)
        self.draw_next_indicator()

        # Draw shortcuts
        self.draw_pause()
        Screen.print_at(35, 24, "Q", COLOR_STATUS_SHORTCUTS, BG_STATUS)
        Screen.print_at(36, 24, "UIT", COLOR_STATUS_TEXT, BG_STATUS)

        self.update_status()
        self.update_time()

        # Initialize progress bar (full at start)
        Screen.draw_progress_bar(PROGRESS_BAR_WIDTH)

    def is_game_over() -> bool:
        """Check if any block reached leftmost column (game over condition)."""
        row: byte
        for row in range(GRID_HEIGHT):
            if self.grid.get_color(0, row):
                return True
        return False

    def start_effect(col: byte):
        """Start column clear effect animation."""
        row: byte
        pos: word
        # Column clear sound - cheerful rising arpeggio chime. Delayed start.
        sfx_pending: byte[ZP_SFX_PENDING] = 1

        # Save original colors
        for row in range(GRID_HEIGHT):
            pos = row_offset_data[PLAY_TOP + row * BLOCK_HEIGHT] + col * BLOCK_WIDTH
            self.effect_saved_colors[row] = Screen.colors[pos] & 0x0F

        # Start effect state machine
        self.effect_col = col
        self.effect_phase = 1
        self.effect_frame = 0

        # Hide bullet sprite during effect animation
        self.sprite_en_zp = self.sprite_en_zp & 0xFD
        Screen.sprite_enable = self.sprite_en_zp | self.star_mask_zp

    def check_complete_columns():
        """
        Check for complete columns and start effect if found.
        Only one effect can run at a time.
        """
        col: byte

        # Don't start new effect if one is already running or cascade is active
        if self.effect_phase != 0 or self.cascade_phase != CASCADE_IDLE:
            return

        # Find first complete column
        for col in range(GRID_WIDTH):
            if self.grid.is_column_complete(col):
                self.effect_from_cascade = False  # Normal clear, no bonus
                self.start_effect(col)
                return

    def update_col_num():
        """Update the column number using col_count array (O(19) RAM reads vs O(200) Color RAM reads)."""
        i: byte
        n: byte = 0
        # col_count[i] = block count for column i+1 (columns 1-19)
        for i in range(19):
            if self.grid.col_count[i] != 0:
                n += 1

        # Store for slide sound decision
        self.active_col_count = n

        # Play music if column number is greater than COLUMN_START_MUSIC
        if not self.music_enabled:
            if n >= COLUMN_START_MUSIC:
                slotshot_music_vic_init()
                music_disable_ch(2)
                self.music_enabled = True
        elif n < COLUMN_START_MUSIC - COLUMN_HISTERESIS:
            music_stop_fade(20)
            self.music_enabled = False

    def find_cascade_opportunity() -> bool:
        """
        Find next row that can slide right.
        Searches from cascade_scan_row onwards.
        Only searches columns up to cascade_max_col (blocks right of removed column don't cascade).
        Returns True if found, sets cascade_row, cascade_src_col, cascade_dst_col.
        """
        row: byte
        col: byte
        first_block_col: byte
        first_empty_col: byte
        found_block: bool
        found_empty: bool

        row = self.cascade_scan_row
        while row < GRID_HEIGHT:
            # Scan row from RIGHT to LEFT, but only up to cascade_max_col
            # Looking for: empty space followed by blocks to its left
            found_empty = False
            first_empty_col = 0
            found_block = False
            first_block_col = 0

            # Start from cascade_max_col + 1 to check if blocks can slide INTO the removed column area
            # After shift, blocks at cascade_max_col may have empty space to their RIGHT (at cascade_max_col+1)
            col = self.cascade_max_col + 1
            if col >= GRID_WIDTH:
                col = GRID_WIDTH - 1
            while col > 0:
                if not found_empty:
                    # Looking for first empty space
                    if not self.grid.get_color(col, row):
                        found_empty = True
                        first_empty_col = col
                else:
                    # Looking for block to the LEFT of empty space
                    if self.grid.get_color(col, row):
                        found_block = True
                        first_block_col = col
                        break
                col -= 1

            if found_block and found_empty and first_block_col < first_empty_col:
                # Found cascade opportunity!
                # Save for next scan iteration
                self.cascade_scan_row = row + 1

                # Find leftmost contiguous block in this row
                # (all blocks from col 0 to first_block_col will slide)
                while first_block_col > 0:
                    if self.grid.get_color(first_block_col - 1, row):
                        first_block_col -= 1
                    else:
                        break

                # Set cascade parameters
                self.cascade_row = row
                self.cascade_src_col = first_block_col
                self.cascade_dst_col = first_empty_col
                return True

            row += 1

        return False

    def start_cascade_scan():
        """
        Start scanning for cascade opportunities.
        Called after column effect completes.
        Only searches columns LEFT of the removed column (effect_col).
        """
        self.cascade_phase = CASCADE_SCAN
        self.cascade_scan_row = 0
        self.cascade_frame = 0
        self.cascade_max_col = self.effect_col  # Only search up to this column

    def update_cascade_slide():
        """
        Animate horizontal slide - 1 character per 2 frames (smooth).
        2 steps = 1 block, chars stay in place (TL stays TL, etc).
        """
        cx: byte
        src_pos: word
        color: byte
        sy: byte
        start_char: byte
        end_char: byte
        current_step: byte
        col: byte
        idx: byte
        row_base: word
        pos_next: word
        has_block_now: bool
        had_block_before: bool

        # Move every 2 frames for smooth animation
        if self.cascade_frame % 2 != 0:
            self.cascade_frame += 1
            return

        # Calculate current step (how many chars we've already moved)
        current_step = self.cascade_frame / 2

        # Check if slide complete (2 character steps = 1 block)
        if current_step >= 2:
            # Update col_count for EVERY column in the slide range
            # The slide moved everything 1 column right, so:
            # - AFTER col[i] = BEFORE col[i-1]
            # - BEFORE col[i] had block ↔ AFTER col[i+1] has block
            sy = PLAY_TOP + self.cascade_row * BLOCK_HEIGHT
            row_base = row_offset_data[sy]

            col = self.cascade_src_col
            while col <= self.cascade_dst_col:
                if col > 0:
                    src_pos = row_base + word(col) * BLOCK_WIDTH
                    has_block_now = (Screen.colors[src_pos] & 0x0F) != BLACK

                    # What was BEFORE at col[i]? = What is AFTER at col[i+1]
                    if col < self.cascade_dst_col:
                        pos_next = row_base + word(col + 1) * BLOCK_WIDTH
                        had_block_before = (Screen.colors[pos_next] & 0x0F) != BLACK
                    else:
                        # dst column: was empty before (first empty slot)
                        had_block_before = False

                    # Update col_count based on change
                    idx = col - 1
                    if has_block_now and not had_block_before:
                        self.grid.col_count[idx] = self.grid.col_count[idx] + 1
                    elif not has_block_now and had_block_before:
                        self.grid.col_count[idx] = self.grid.col_count[idx] - 1
                col += 1

            self.cascade_phase = CASCADE_SETTLE
            self.cascade_frame = 0
            return

        sy = PLAY_TOP + self.cascade_row * BLOCK_HEIGHT

        # Character range to move - TRACK where blocks are NOW
        start_char = self.cascade_src_col * BLOCK_WIDTH + current_step
        end_char = self.cascade_dst_col * BLOCK_WIDTH + current_step

        # SWAP only the affected region's screen chars (TL↔TR, BL↔BR)
        # Next step will swap back - after 2 swaps it returns to normal
        for cx in range(self.cascade_src_col * BLOCK_WIDTH, (self.cascade_dst_col + 1) * BLOCK_WIDTH):
            # Top row - swap TL↔TR
            src_pos = row_offset_data[sy] + cx
            if Screen.screen[src_pos] == CHAR_BLOCK_TL:
                Screen.screen[src_pos] = CHAR_BLOCK_TR
            else:
                Screen.screen[src_pos] = CHAR_BLOCK_TL
            # Bottom row - swap BL↔BR
            src_pos = row_offset_data[sy + 1] + cx
            if Screen.screen[src_pos] == CHAR_BLOCK_BL:
                Screen.screen[src_pos] = CHAR_BLOCK_BR
            else:
                Screen.screen[src_pos] = CHAR_BLOCK_BL

        # Now shift COLOR RAM 1 position right (process RIGHT to LEFT)
        cx = end_char - 1
        while cx >= start_char:
            # Top row - move color only
            src_pos = row_offset_data[sy] + cx
            color = Screen.colors[src_pos] & 0x0F
            if color != BLACK:
                Screen.colors[src_pos + 1] = color
                Screen.colors[src_pos] = BLACK
            # Bottom row - move color only
            src_pos = row_offset_data[sy + 1] + cx
            color = Screen.colors[src_pos] & 0x0F
            if color != BLACK:
                Screen.colors[src_pos + 1] = color
                Screen.colors[src_pos] = BLACK

            if cx == 0:
                break
            cx -= 1

        self.cascade_frame += 1

    def update_cascade_settle():
        """Brief settle pause after slide."""
        self.cascade_frame += 1
        if self.cascade_frame >= 3:  # 3 frames settle
            self.cascade_phase = CASCADE_CHECK
            self.cascade_frame = 0

    def update_cascade_check():
        """Check for complete columns after cascade."""
        col: byte

        # Look for complete columns
        for col in range(GRID_WIDTH):
            if self.grid.is_column_complete(col):
                # Found complete column - start column effect
                # Cascade will resume after column effect completes
                self.cascade_phase = CASCADE_IDLE
                self.effect_from_cascade = True  # Bonus points for cascade clear!
                self.start_effect(col)
                return

        # No complete column - continue scanning for more cascade opportunities
        self.cascade_phase = CASCADE_SCAN

    def update_cascade():
        """Main cascade state machine - call every frame."""

        if self.cascade_phase == CASCADE_IDLE:
            return

        elif self.cascade_phase == CASCADE_SCAN:
            if self.find_cascade_opportunity():
                # Skip flash, go directly to smooth slide
                self.cascade_phase = CASCADE_SLIDE
                self.cascade_frame = 0
                sfx_play_slide()
            else:
                # No more cascade opportunities - all done!
                self.cascade_phase = CASCADE_IDLE
                # Load next bullet into cannon (bullet_type IS the color!)
                self.bullet_type_zp = self.next_bullet_type_zp
                Screen.sprite_color[1] = self.bullet_type_zp
                # Re-enable bullet sprite now that all effects complete
                self.sprite_en_zp = self.sprite_en_zp | 0x02
                Screen.sprite_enable = self.sprite_en_zp | self.star_mask_zp
                # NOW determine next bullet type (indicator shows what comes AFTER loaded one)
                self.determine_next_bullet()
                # Check for complete columns that may have formed during cascade
                # (bullet hit during cascade doesn't trigger check_complete_columns)
                self.check_complete_columns()
                # Restore cannon sprite ONLY if no new effect started
                if self.effect_phase == 0:
                    Screen.sprite_ptr[0] = CANNON_BLOCK_READY

        elif self.cascade_phase == CASCADE_SLIDE:
            self.update_cascade_slide()

        elif self.cascade_phase == CASCADE_SETTLE:
            self.update_cascade_settle()

        elif self.cascade_phase == CASCADE_CHECK:
            self.update_cascade_check()

    def update_effect():
        """
        Update effect state machine - call every frame.
        Returns when effect completes (removes column, updates score).
        """
        row: byte
        sx: byte
        base_pos: word
        color: byte

        # No effect running
        if self.effect_phase == 0:
            return

        # Calculate screen X position
        sx = self.effect_col * BLOCK_WIDTH

        # Set colors based on current phase (odd=black, even=original)
        if self.effect_phase & 1:
            color = BLACK

        for row in range(GRID_HEIGHT):
            base_pos = row_offset_data[PLAY_TOP + row * BLOCK_HEIGHT] + sx
            if self.effect_phase & 1:
                # Odd phases: BLACK (invisible)
                Screen.colors[base_pos] = BLACK
                Screen.colors[base_pos + 1] = BLACK
                Screen.colors[base_pos + 40] = BLACK
                Screen.colors[base_pos + 41] = BLACK
            else:
                # Even phases: Original colors
                Screen.colors[base_pos] = self.effect_saved_colors[row]
                Screen.colors[base_pos + 1] = self.effect_saved_colors[row]
                Screen.colors[base_pos + 40] = self.effect_saved_colors[row]
                Screen.colors[base_pos + 41] = self.effect_saved_colors[row]

        # Advance frame counter
        self.effect_frame += 1
        if self.effect_frame >= 3:
            self.effect_frame = 0
            self.effect_phase += 1

            # Effect complete?
            if self.effect_phase > 7:
                self.effect_phase = 0

                # FIRST: Clear the removed column's col_count (it's now empty!)
                # This must happen BEFORE shift check, otherwise infinite loop occurs
                if self.effect_col > 0:
                    self.grid.col_count[self.effect_col - 1] = 0

                # Only shift columns if there are blocks to the left of the removed column
                # Formula: if (GRID_WIDTH - effect_col) < active_col_count, there are blocks to the left
                # This saves CPU time by skipping unnecessary blkcpy calls when nothing would move
                if GRID_WIDTH - self.effect_col < self.active_col_count:
                    self.grid.shift_columns_right(self.effect_col)
                    sfx_play_slide()

                # Update score (cascade clears give bonus points!)
                # Formula: base_score + (level - 1) * level_bonus
                self.cols_cleared += 1
                if self.effect_from_cascade:
                    self.score += SCORE_CASCADE_CLEAR + word(self.level - 1) * SCORE_LEVEL_BONUS
                else:
                    self.score += SCORE_COLUMN_CLEAR + word(self.level - 1) * SCORE_LEVEL_BONUS

                # Immediately show player's score (not H-SCORE) when scoring
                self.showing_high_score = False
                self.score_display_timer = 0

                # Level up check (BEFORE update_status so level displays immediately!)
                # Max level determined by len(level_speeds_data)
                while self.level < len(level_speeds_data):
                    if self.cols_cleared >= cleared_thresholds_data[self.level - 1]:
                        self.level += 1
                        self.column_speed = level_speeds_data[self.level - 1]
                        self.level_flash = 80  # Start 5x flash animation (80 frames / 8 = 10 phases)
                        sfx_play_bibip()
                    else:
                        break

                self.update_status()
                self.update_col_num()

                # Start cascade scan (sprite restore moved to cascade completion)
                self.start_cascade_scan()

    def update_dying_blocks():
        """
        Animate dying blocks through DYING_COLORS phases.
        Called every frame, runs independently of other animations.
        When animation completes (blocks turn BLACK), col_count is decremented
        for each dying block to keep the count accurate.
        """
        i: byte
        pos: word
        color: byte
        col: byte
        idx: byte
        xy: XY

        # No dying blocks?
        if self.grid.dying_count == 0:
            return

        # Not started yet?
        if self.dying_phase == 0:
            return

        # Get color for current phase (phase 1 = index 0, etc.)
        color = dying_colors_data[self.dying_phase - 1]

        # Apply color to all dying blocks
        for i in range(self.grid.dying_count):
            xy = self.grid.dying_positions[i]
            pos = row_offset_data[xy.y] + xy.x
            Screen.colors[pos] = color
            Screen.colors[pos + 1] = color
            Screen.colors[pos + 40] = color
            Screen.colors[pos + 41] = color

        # Advance frame counter
        self.dying_frame += 1
        if self.dying_frame >= 2:  # 2 frames per phase
            self.dying_frame = 0
            self.dying_phase += 1

            # Animation complete? (tuple length determines phase count)
            if self.dying_phase > len(dying_colors_data):
                # Decrement col_count for each dying block that just turned BLACK
                for i in range(self.grid.dying_count):
                    xy = self.grid.dying_positions[i]
                    col = xy.x >> 1  # Screen x to grid column (no modulo needed!)
                    if col > 0:  # Not the cannon column
                        idx = col - 1
                        self.grid.col_count[idx] = self.grid.col_count[idx] - 1
                self.dying_phase = 0
                self.grid.dying_count = 0  # Clear the dying list

    def start_dying_animation():
        """Start dying animation if there are blocks to animate."""
        if self.grid.dying_count > 0:
            self.dying_phase = 1
            self.dying_frame = 0

    def init_sprites():
        """
        Initialize sprite VIC registers (data already in Sprites singleton).
        Sprite 0: cannon (multicolor), Sprite 1: bullet (hires), Sprite 2: sparkle.
        """
        sparkle_phase: byte[ZP_SPARKLE_PHASE]

        # Initialize star sprites (3-7) for game field background
        Sprites.init_stars(game_star_positions_data, LIGHT_GREY)

        # Setup multicolor mode for cannon sprite
        Screen.sprite_mc1 = DARK_GREY   # Multicolor 1 ($D025)
        Screen.sprite_mc2 = CYAN        # Multicolor 2 ($D026)
        Screen.sprite_multicolor = 0x01 # Only sprite 0 is multicolor

        # Setup sprite 0: cannon
        Screen.sprite_ptr[0] = CANNON_BLOCK_READY
        Screen.sprite_color[0] = GREY   # Sprite 0 individual color

        # Setup sprite 1: bullet (hires, not multicolor)
        Screen.sprite_ptr[1] = BULLET_BLOCK
        Screen.sprite_color[1] = COLOR_BULLET

        # Setup sprite 2: sparkle (hires, single sprite with color fade)
        Screen.sprite_color[2] = COLOR_SPARKLE_1  # Initial color (will change during animation)
        Screen.sprite_ptr[2] = SPARKLE_BLOCK      # Sparkle pattern
        sparkle_phase = 0  # Sparkle starts inactive

        # DEBUG: All sprites in FRONT to test visibility
        Screen.sprite_priority = 0x00  # All sprites in front (debug)

        # Initialize ZP variables
        self.cannon_row_zp = 4  # Start in middle
        self.cannon_target_zp = PLAY_TOP * 8 + 4 * 16 + SPRITE_Y_OFFSET
        self.cannon_current_zp = self.cannon_target_zp
        self.bullet_active_zp = 0
        self.bullet_hit_col_zp = 255
        self.sprite_en_zp = 0x03  # Enable cannon + bullet only (stars managed by star_mask_zp)

        # Enable both sprites (bullet sprite always visible, follows cannon when not fired)
        Screen.sprite_enable = 0x03

        # Set cannon initial position
        Screen.sprite_x[0] = CANNON_SPRITE_X  # Sprite 0 X
        Screen.sprite_x[1] = self.cannon_current_zp  # Sprite 0 Y

        # Set bullet sprite initial position (inside cannon barrel)
        Screen.sprite_x[2] = CANNON_SPRITE_X  # Sprite 1 X
        Screen.sprite_x[3] = self.cannon_current_zp  # Sprite 1 Y

    def cleanup():
        """Clean up game resources (IRQ, sprites)."""
        # Disable raster IRQ and reset handler
        __set_irq__(irq_screen_handler)
        __set_raster__(TITLE_RASTER_TO_BITMAP)
        # Disable all sprites
        Screen.sprite_enable = 0

    def cannon_move_up():
        """Move cannon up (sets target Y, IRQ handles smooth movement)."""
        row: byte
        row = self.cannon_row_zp
        if row > 0:
            row -= 1
            self.cannon_row_zp = row
            self.cannon_target_zp = PLAY_TOP * 8 + word(row) * 16 + SPRITE_Y_OFFSET

    def cannon_move_down():
        """Move cannon down."""
        row: byte
        row = self.cannon_row_zp
        if row < GRID_HEIGHT - 1:
            row += 1
            self.cannon_row_zp = row
            self.cannon_target_zp = PLAY_TOP * 8 + word(row) * 16 + SPRITE_Y_OFFSET

    def fire_bullet():
        """Fire bullet (sets ZP variables, IRQ handles movement)."""
        start_x: word
        start_y: byte
        scan_col: byte
        scan_pos: word
        scan_color: byte
        found_wall: byte
        has_gap: byte
        screen_y: byte
        color_ram: array[byte, 1000][COLOR]

        # Can't fire if bullet already active, effect is playing, or cascade is active
        if self.bullet_active_zp != 0 or self.effect_phase != 0 or self.cascade_phase != CASCADE_IDLE:
            return

        # Can't fire if out of points - GAME OVER!
        if self.score == 0:
            # Hide bullet sprite for game over screen
            self.sprite_en_zp = self.sprite_en_zp & 0xFD
            Screen.sprite_enable = self.sprite_en_zp | self.star_mask_zp
            self.game_over = True
            self.running = False
            return

        # Play fire sound
        sfx_play_fire()

        # Each shot costs 1 point
        self.score -= 1
        self.update_status()
        self.update_col_num()

        # NOTE: bullet_type_zp already contains the loaded bullet type!
        # (Set during init or previous handle_bullet_hit)

        # Initialize yellow bullet state machine
        if self.bullet_type_zp == COLOR_BULLET_YELLOW:
            # Pre-scan the row to check if there's a gap (wall followed by empty)
            screen_y = PLAY_TOP + self.cannon_row_zp * BLOCK_HEIGHT
            found_wall = 0
            has_gap = 0
            scan_col = 1  # Start after cannon column

            while scan_col < GRID_WIDTH and has_gap == 0:
                scan_pos = row_offset_data[screen_y] + word(scan_col) * BLOCK_WIDTH
                scan_color = (color_ram[scan_pos] | color_ram[scan_pos + 1] | color_ram[scan_pos + 40] | color_ram[scan_pos + 41]) & 0x0F
                if scan_color != BLACK:
                    # Hit a wall
                    found_wall = 1
                elif found_wall != 0:
                    # Empty after wall = gap found!
                    has_gap = 1
                scan_col += 1

            if has_gap != 0:
                # Gap exists - use normal yellow 3-state machine
                self.yellow_state_zp = YELLOW_STATE_BEFORE_WALL
            else:
                # No gap - behave like white (stop at first wall)
                self.yellow_state_zp = YELLOW_STATE_AS_WHITE
            self.yellow_last_empty_zp = 0xFF  # Reset to invalid marker

        # NOTE: next bullet type is determined in handle_bullet_hit() when bullet lands
        # This ensures the "Next" indicator shows what comes AFTER the loaded bullet

        # Switch cannon sprite to "fired" state (empty barrel)
        Screen.sprite_ptr[0] = CANNON_BLOCK_FIRED

        # Calculate starting position (bullet starts at cannon position)
        start_x = word(CANNON_SPRITE_X)
        # Y position calculated from grid row, not interpolated sprite position!
        # This ensures bullet starts at correct row even if cannon is mid-movement
        start_y = PLAY_TOP * 8 + word(self.cannon_row_zp) * 16 + SPRITE_Y_OFFSET

        # Set bullet ZP variables (store cannon row at firing time!)
        # CRITICAL: Set active flag LAST! IRQ checks this first before using other values.
        # NOTE: Do NOT reset bullet_hit_col_zp here! If there's a pending hit from the
        # previous bullet, handle_bullet_hit() must process it first. The reset happens
        # inside handle_bullet_hit() after processing.
        self.bullet_x_zp = start_x
        self.bullet_y_zp = start_y
        self.bullet_row_zp = self.cannon_row_zp  # Lock in the row!
        # Pre-calculate row base for IRQ (avoids tuple lookup every frame!)
        self.bullet_row_base_zp = row_offset_data[PLAY_TOP + self.cannon_row_zp * BLOCK_HEIGHT]
        self.bullet_active_zp = 1  # Enable AFTER all values are set!

        # Enable bullet sprite (may have been hidden by collision in IRQ)
        self.sprite_en_zp = self.sprite_en_zp | 0x02
        Screen.sprite_enable = self.sprite_en_zp | self.star_mask_zp

    def handle_input():
        """
        Handle keyboard and joystick input.
        Joystick is injected into keyboard buffer by IRQ, so we can use the same key handling code.
        """
        key: char
        jiffy_lo: byte[JIFFY_LO_ADDR]
        key = getkey()

        # P toggles pause (works even while paused!)
        if key == KEY_P or key == KEY_P_LOWER or (key == KEY_SPACE and self.paused):
            if self.paused:
                self.paused = False
                self.draw_pause()
                self.last_jiffy = jiffy_lo
            else:
                self.paused = True
                self.draw_pause()
            return

        if key == KEY_Q or key == KEY_Q_LOWER:
            self.running = False

        # Other keys only work when NOT paused
        if self.paused:
            return

        if key == KEY_UP or key == KEY_W or key == KEY_W_LOWER:
            self.cannon_move_up()
        elif key == KEY_DOWN or key == KEY_S or key == KEY_S_LOWER:
            self.cannon_move_down()
        elif key == KEY_SPACE:
            self.fire_bullet()

    def handle_bullet_hit():
        """Handle bullet hit - IRQ places blocks and returns placed column, we update col_count."""
        hit_col: byte
        idx: byte

        if self.bullet_hit_col_zp == 255:
            return

        hit_col = self.bullet_hit_col_zp  # Read BEFORE reset!
        self.bullet_hit_col_zp = 255      # Reset to "no hit"

        # Update block count for placed column (column 1 = index 0)
        # Note: Use explicit read-modify-write because PyCo doesn't support += on subscripts
        if hit_col > 0:
            idx = hit_col - 1
            self.grid.col_count[idx] = self.grid.col_count[idx] + 1

        # Hit column 0 means block placed in cannon column - game over!
        # This means the row is completely blocked - immediate game over!
        if hit_col == 0:
            # Check if there's actually a block in col 0 (game over condition)
            if self.is_game_over():
                # Switch to empty cannon sprite - the killer block shows through!
                Screen.sprite_ptr[0] = CANNON_BLOCK_FIRED
                # Hide bullet sprite for game over screen
                self.sprite_en_zp = self.sprite_en_zp & 0xFD
                Screen.sprite_enable = self.sprite_en_zp | self.star_mask_zp
                self.game_over = True
                self.running = False
                return
            # No block in col 0 - just restore cannon state
            if self.effect_phase == 0:
                Screen.sprite_ptr[0] = CANNON_BLOCK_READY
                # Load next bullet into cannon (bullet_type IS the color!)
                self.bullet_type_zp = self.next_bullet_type_zp
                Screen.sprite_color[1] = self.bullet_type_zp
                # Re-enable bullet sprite (was hidden by IRQ on collision)
                self.sprite_en_zp = self.sprite_en_zp | 0x02
                Screen.sprite_enable = self.sprite_en_zp | self.star_mask_zp
                # NOW determine next bullet type (indicator shows what comes AFTER loaded one)
                self.determine_next_bullet()
            return

        # Check for complete columns
        self.check_complete_columns()
        self.update_status()

        # Restore cannon sprite only if no effect started
        if self.effect_phase == 0:
            Screen.sprite_ptr[0] = CANNON_BLOCK_READY
            # Load next bullet into cannon (bullet_type IS the color!)
            self.bullet_type_zp = self.next_bullet_type_zp
            Screen.sprite_color[1] = self.bullet_type_zp
            # Re-enable bullet sprite (was hidden by IRQ on collision)
            self.sprite_en_zp = self.sprite_en_zp | 0x02
            Screen.sprite_enable = self.sprite_en_zp | self.star_mask_zp
            # NOW determine next bullet type (indicator shows what comes AFTER loaded one)
            self.determine_next_bullet()

    def do_scroll():
        """Move grid left using blkcpy and draw new column."""
        jiffy_lo: byte[JIFFY_LO_ADDR]
        elapsed: byte

        # Pause scrolling during effect or cascade ("time freeze")
        # IMPORTANT: Update last_jiffy to prevent time accumulation!
        # Without this, elapsed time during animation would be added after it ends.
        if self.effect_phase != 0 or self.cascade_phase != CASCADE_IDLE:
            self.last_jiffy = jiffy_lo
            return

        # If dying animation is running, wait for it to finish
        if self.dying_phase != 0:
            return

        # If scroll is NOT pending, check timer and do aging
        if not self.scroll_pending:
            # Handle bullet hit detected by IRQ BEFORE scroll
            # This processes gravity and effects before the grid moves
            self.handle_bullet_hit()

            # Delta timing using jiffy clock (60 Hz, platform independent)
            # Byte subtraction automatically handles wraparound (0-255)
            elapsed = jiffy_lo - self.last_jiffy
            self.last_jiffy = jiffy_lo
            self.move_timer = self.move_timer + word(elapsed)
            if self.move_timer < self.column_speed:
                return

            self.move_timer = 0

            # Age player blocks BEFORE scroll (WHITE → LIGHT_GREY → GREY → DARK_GREY)
            # DARK_GREY blocks get added to dying list for flash animation
            self.grid.age_player_blocks()

            # Start dying animation if there are blocks to animate
            self.start_dying_animation()
            if self.dying_phase != 0:
                self.scroll_pending = True  # Scroll due after animation
                return

        # Scroll is pending (or no dying animation) - do the scroll!
        self.scroll_pending = False

        # === ATOMIC SCROLL SEQUENCE ===
        # The entire scroll + spawn + bullet_x adjustment must be atomic!
        # If IRQ fires between scroll and bullet_x adjustment:
        # - Grid is already shifted (scroll done)
        # - But bullet_x still has OLD value
        # - IRQ collision check uses OLD bullet_x with NEW grid
        # - Result: collision check is off by 1 column → bullet passes through blocks!

        __sei__()  # Disable IRQ for entire atomic sequence

        # 1. Scroll play area left (Color RAM + col_count array)
        blkcpy(Screen.colors, 82, Screen.colors, 80, 38, 20, 40)
        self.grid.shift_col_count_left()

        # 2. Spawn new column directly to Color RAM (sets col_count[18])
        self.grid.spawn_column()

        # 3. Adjust bullet position to match shifted grid
        if self.bullet_active_zp != 0:
            if self.bullet_x_zp > 16:
                self.bullet_x_zp = self.bullet_x_zp - 16
            else:
                self.bullet_active_zp = 0
                Screen.sprite_ptr[0] = CANNON_BLOCK_READY

        # 4. Adjust pending bullet hit column (IRQ may have set this BEFORE scroll!)
        # The grid shifted left, so the hit column is now 1 less
        # 255=no hit (skip), 0=game over (skip), 1-19=valid (decrement)
        if self.bullet_hit_col_zp > 0 and self.bullet_hit_col_zp < GRID_WIDTH:
            self.bullet_hit_col_zp = self.bullet_hit_col_zp - 1

        __cli__()  # NOW IRQ can run - grid and bullet_x are synchronized!

        # === END ATOMIC SEQUENCE ===

        # Check game over AFTER scroll - if any block reached leftmost column
        if self.is_game_over():
            # Switch to empty cannon sprite - the killer block shows through!
            Screen.sprite_ptr[0] = CANNON_BLOCK_FIRED
            # Hide bullet sprite for game over screen
            self.sprite_en_zp = self.sprite_en_zp & 0xFD
            Screen.sprite_enable = self.sprite_en_zp | self.star_mask_zp
            self.game_over = True
            self.running = False
            return

        # Handle any collision detected by IRQ after scroll
        self.handle_bullet_hit()

        # Update column number
        self.update_col_num()

    def try_spawn_sparkle():
        """Try to spawn a sparkle effect on a random colored tile."""
        sparkle_phase: byte[ZP_SPARKLE_PHASE]
        sparkle_pos: word[ZP_SPARKLE_POS]
        sprite_x: array[byte, 16][SPRITE_X]
        sprite_y: array[byte, 16][SPRITE_Y]
        sprite_x_msb: byte[SPRITE_X_MSB]
        grid_x: byte
        grid_y: byte
        screen_x: byte
        screen_y: byte
        pos: word
        color: byte
        sprite_px: word
        sprite_py: byte

        # Only spawn if sparkle sprite is free (phase == 0)
        if sparkle_phase != 0:
            return

        # Random chance to spawn (higher = rarer, 255 = never, 0 = every frame)
        if Random.next() < SPARKLE_SPAWN_CHANCE:
            return

        # Pick random grid position
        grid_x = Random.range(GRID_WIDTH)   # 0-19
        grid_y = Random.range(GRID_HEIGHT)  # 0-9

        # Calculate screen position and check color
        screen_y = PLAY_TOP + grid_y * BLOCK_HEIGHT
        screen_x = grid_x * BLOCK_WIDTH
        pos = row_offset_data[screen_y] + screen_x

        # Check if there's a colored block here (not black)
        color = Screen.colors[pos] & 0x0F
        if color != BLACK:
            # Valid position - activate sparkle!
            # Calculate sprite pixel position
            sprite_px = word(screen_x) * 8 + SPRITE_X_OFFSET
            sprite_py = screen_y * 8 + SPRITE_Y_OFFSET

            # Set sprite 2 position
            sprite_x[4] = sprite_px & 0xFF
            sprite_y[4] = sprite_py

            # Handle X MSB (bit 2 for sprite 2)
            if sprite_px > 255:
                sprite_x_msb = sprite_x_msb | 0x04
            else:
                sprite_x_msb = sprite_x_msb & 0xFB

            # Enable sprite 2 and set phase to start animation
            self.sprite_en_zp = self.sprite_en_zp | 0x04
            Screen.sprite_enable = self.sprite_en_zp | self.star_mask_zp
            sparkle_pos = pos  # Save position for IRQ validation
            sparkle_phase = 1  # Start animation

    def update():
        """
        Update the game state

        - Sprite movement and collision detection handled by raster IRQ (irq_handler)
        - Grid scroll (handles timing and column generation)
        - Update progress bar (shows time until next column)
        - Update elapsed time periodically (~4x per second)
        - Sparkle effect - random tile highlights
        """
        filled: byte
        jiffy_lo: byte[JIFFY_LO_ADDR]

        # Skip all updates while paused (but keep delta timing baseline fresh!)
        if self.paused:
            return

        # Update cascade animation (must be before effect, as cascade may trigger effect)
        self.update_cascade()

        # Update effect animation (non-blocking state machine)
        self.update_effect()

        # Update dying blocks animation (flash before disappearing)
        self.update_dying_blocks()

        # Update level flash animation (5x blink on level-up)
        self.update_level_flash()

        # Update score/high score alternating display
        self.update_score_display()

        # Handle any bullet hit detected by IRQ
        self.handle_bullet_hit()

        # Grid scroll (handles timing and column generation)
        self.do_scroll()

        # Update progress bar (shows time until next column)
        # Bar depletes from right to left as move_timer approaches column_speed
        filled = ((self.column_speed - self.move_timer) * PROGRESS_BAR_WIDTH) / self.column_speed
        Screen.draw_progress_bar(filled)

        # Update elapsed time periodically (~4x per second)
        # jiffy_lo changes at 60Hz, so & 15 = every 16 ticks
        if (jiffy_lo & 15) == 0:
            self.update_time()
            self.update_status()

        # Sparkle effect - random tile highlights
        self.try_spawn_sparkle()

    def show_game_over_window():
        """Draw game over dialog with grey background (same as status bar)."""
        x: byte
        y: byte
        pos: word
        pak_color: byte
        pak_visible: bool = False
        pak_y: byte

        for y in range(8, 16):
            pos = row_offset_data[y]
            for x in range(10, 30):
                Screen.screen[pos + x] = CHAR_SPACE + BG_STATUS
                Screen.colors[pos + x] = WHITE  # This hides stars in front of window

        # Show "NEW HIGHSCORE!" if player beat the high score
        if self.high_score_beaten:
            Screen.print_center(9, "CONGRATULATIONS!", WHITE, BG_STATUS)
            Screen.print_center(12, "NEW HIGHSCORE!", LIGHT_RED, BG_STATUS)
            pak_y = 14
        else:
            Screen.print_center(10, "GAME OVER!", WHITE, BG_STATUS)
            pak_y = 13

        # Clear key buffer
        while getkey() != 0:
            pass

        # Press A Key prompt
        while True:
            if pak_visible:
                pak_color = DARK_GREY
                pak_visible = False
            else:
                pak_color = YELLOW
                pak_visible = True
            Screen.print_center(pak_y, "PRESS A KEY!", pak_color, BG_STATUS)
            for _ in range(10):
                Screen.wait_frames(2)
                if getkey() != 0:
                    return

    def loop():
        # Main game loop
        while self.running:
            self.handle_input()
            Screen.sync_raster(IRQ_RASTER_PLAY_AREA_BOTTOM)
            self.update()

        if self.game_over:
            # Update high score before showing game over window
            if self.score > HighScore.score:
                HighScore.score = self.score
            music_stop_fade(25)

            # Refresh status bar to show player's score (not alternating H-SCORE)
            self.update_status()

            # Border and status bar flash animation (red flashing)
            for _ in range(5):
                Screen.wait_frames(1)
                Screen.border = COLOR_GAME_OVER_FLASH
                Screen.bg2 = COLOR_GAME_OVER_FLASH
                Screen.wait_frames(8)
                Screen.border = COLOR_SCREEN_BORDER
                Screen.bg2 = COLOR_STATUS_BG
                Screen.wait_frames(8)

            # Play game over music
            music_set_volume(5)
            if not self.high_score_beaten:
                slotshot_gameover_music_vic_init()
            else:
                slotshot_highscore_music_vic_init()
            music_enable_all_ch()
            music_disable_loop()

            self.show_game_over_window()

        # Clean up before returning to title screen
        self.cleanup()

    def __init__():
        # Timer ZP variables (must be initialized before IRQ starts!)
        frame_counter: byte[ZP_FRAME_COUNTER] = 0
        game_seconds: word[ZP_GAME_SECONDS] = 0
        jiffy_lo: byte[JIFFY_LO_ADDR]

        # Fill play area with block characters (color determines visibility)
        Screen.init_play_area()
        # Set up VIC for ECM text mode (game mode)
        Screen.set_game_mode()
        Screen.border = COLOR_SCREEN_BORDER

        self.column_speed = level_speeds_data[0]  # Level 1 speed from tuple
        self.last_jiffy = jiffy_lo  # Initialize delta timing baseline

        # Initialize bullet types - first bullet is ALWAYS white for consistency
        # NOTE: bullet_type IS the color (no separate type/color mapping!)
        self.bullet_type_zp = COLOR_BULLET
        self.next_bullet_type_zp = COLOR_BULLET  # First loaded in cannon is white
        # Sprite color will be set to white by init_sprites() below

        # Draw title screen
        self.draw_title()
        # Draw status bar
        self.draw_status()
        # Determine what comes AFTER the first white bullet (shown in "Next" indicator)
        self.determine_next_bullet()

        # Initialize sprites
        self.init_sprites()

        # Initialize raster IRQ (sprite updates and joystick)
        __set_irq__(irq_handler)
        __enable_raster_irq__(IRQ_RASTER_PLAY_AREA_BOTTOM)

        # Initialize column pool (pre-generate random patterns)
        self.grid()

        # Spawn initial columns to start with a populated grid
        # NOTE: scroll first, then spawn - so the last column stays at col 19
        for _ in range(INITIAL_COLUMNS):
            blkcpy(Screen.colors, 82, Screen.colors, 80, 38, 20, 40)
            self.grid.shift_col_count_left()  # Match Color RAM scroll
            self.grid.spawn_column()

        # Wait for music to stop
        while not music_is_stopped():
            pass
        # Clear key buffer
        while getkey() != 0:
            pass

        # Set music volume
        music_set_volume(9)

        # Run game loop
        self.loop()

        # Restore music volume to 15 (full volume)
        music_set_volume(15)
        music_enable_all_ch()


# =============================================================================
# SCREEN CLASSES
# =============================================================================

def press_a_key(x: byte, y: byte):
    visible: bool = False
    color: byte = BLACK
    while True:
        if visible:
            color = BLACK
            visible = False
        else:
            color = LIGHT_BLUE
            visible = True
        Screen.print_at(x, y, "PRESS A KEY!", color, BG_PLAY)
        for _ in range(10):
            Screen.wait_frames(2)
            if getkey() != 0:
                return


class TitleScreen:
    """Title screen with RLE compressed Koala image and raster-split menu."""
    # Memory-mapped destinations (VIC Bank 3)
    # Screen RAM is SHARED between bitmap color and text menu
    bitmap_dest: array[byte, 8000][BITMAP_ADDR] = [0]
    screen_data: array[byte, 1000][SCREEN]
    colorram: array[byte, 1000][COLOR] = [BLACK]

    stabilizer_screen: array[byte, 40][SCREEN + 760] = [0]
    stabilizer_color: array[byte, 40][COLOR + 760] = [BLACK]

    # Menu area (rows 21-24) - uses shared screen at offset 840
    menu_screen: array[byte, 160][SCREEN + 840] = [CHAR_SPACE]
    menu_color: array[byte, 160][COLOR + 840]

    # Menu state
    menu_selected: byte[ZP_MENU_SELECTED]

    # Backup for neon flash - reuse game's column buffer area
    screen_backup: array[byte, 24][COLUMN_BUFFER_ADDR]
    flash_part: byte = 0  # 0 = SLOT (first 11), 1 = SHOT (remaining 12)

    def decompress_image():
        """Decompress RLE image data to VIC memory."""
        # Decompress to destinations
        rle_decompress(colorram_rle, self.colorram)
        rle_decompress(screen_rle, self.screen_data)
        rle_decompress(bitmap_rle, self.bitmap_dest)

    def draw_menu():
        """Draw menu items using Screen.print_at."""
        # bg=0 because we're in normal text mode, not ECM
        Screen.print_center_at_offset(MENU_ROW_START, "PLAY GAME", COLOR_MENU_NORMAL, 0, -1)
        Screen.print_center_at_offset(MENU_ROW_START + 1, "STORY", COLOR_MENU_NORMAL, 0, -1)
        Screen.print_center_at_offset(MENU_ROW_START + 2, "ABOUT", COLOR_MENU_NORMAL, 0, -1)
        Screen.print_center_at_offset(MENU_ROW_START + 3, "DONATE ME", COLOR_MENU_NORMAL, 0, -1)

    def update_menu_highlight():
        """Update menu item colors based on selection."""
        i: byte
        j: byte
        pos: word
        color: byte
        for i in range(MENU_ROW_START, MENU_ROW_START + MENU_ITEM_COUNT):
            pos = row_offset_data[i]
            if i == self.menu_selected + MENU_ROW_START:
                color = COLOR_MENU_SELECTED
            else:
                color = COLOR_MENU_NORMAL
            # Color the entire menu item (10 chars wide)
            for j in range(13, 26):
                self.colorram[pos + j] = color

    def flash_darken():
        """Save screen RAM and darken white to light grey for SLOT or SHOT."""
        col: byte
        idx: word
        val: byte
        start: byte
        count: byte

        # Random choice: SLOT (0) or SHOT (1)
        self.flash_part = Random.next() & 1

        if self.flash_part == 0:
            # SLOT: first 11 characters
            start = 0
            count = 11
        else:
            # SHOT: remaining 12 characters
            start = 11
            count = 12

        idx = 3 * 40 + 8 + word(start)
        for col in range(count):
            val = self.screen_data[idx]
            self.screen_backup[col] = val
            if (val >> 4) == WHITE:
                self.screen_data[idx] = (val & 0x0F) | (LIGHT_GREY << 4)
            if (val & 0x0F) == WHITE:
                self.screen_data[idx] = (self.screen_data[idx] & 0xF0) | LIGHT_GREY
            idx += 1

    def flash_restore():
        """Restore screen RAM from backup for the previously darkened part."""
        col: byte
        idx: word
        start: byte
        count: byte

        # Restore the previously darkened part
        if self.flash_part == 0:
            start = 0
            count = 11
        else:
            start = 11
            count = 12

        idx = 3 * 40 + 8 + word(start)
        for col in range(count):
            self.screen_data[idx] = self.screen_backup[col]
            idx += 1

    def cleanup():
        """Clean up title screen resources (IRQ, sprites, etc.)."""
        cia1_icr: byte[CIA1_ICR]

        Screen.sync_raster(IRQ_RASTER_BOTTOM)

        # Disable star sprites (bits 3-7)
        Screen.sprite_enable &= 0x07

        memfill(self.bitmap_dest, 0)
        memfill(self.colorram, BLACK)
        memfill(self.screen_data, CHAR_SPACE)

        Screen.sync_raster(IRQ_RASTER_BOTTOM)
        __set_irq__(irq_screen_handler)
        cia1_icr = 0x81  # Reenable CIA1 if it was disabled by the irq handler

    def wait_menu():
        # Display title screen, return selection: 0=Play, 2=Story, 3=Credits
        key: byte
        frame_counter: byte = 0
        flash_delay: byte = 190
        flash_count: byte = 0
        is_dark: byte = 0
        shimmer: byte = 60        # >= 14: timer (counting down), < 14: active position
        base: word

        # Draw menu
        self.draw_menu()
        self.update_menu_highlight()

        # Menu loop
        while True:
            Screen.sync_raster(IRQ_RASTER_BOTTOM)

            # Neon flash on title
            frame_counter += 1
            if frame_counter >= flash_delay:
                frame_counter = 0
                if flash_count == 0:
                    flash_count = 3 + Random.range_mask(3)
                    self.flash_darken()
                    is_dark = 1
                    flash_delay = 5
                elif is_dark:
                    self.flash_restore()
                    is_dark = 0
                    flash_count -= 1
                    if flash_count > 0:
                        flash_delay = 5
                    else:
                        flash_delay = 190 + Random.range_mask(63)
                else:
                    self.flash_darken()
                    is_dark = 1
                    flash_delay = 2

            # Shimmer on selected menu item (every 2nd frame = slower)
            base = row_offset_data[self.menu_selected + MENU_ROW_START] + 13
            if shimmer > 26:
                shimmer -= 1
            elif shimmer == 26:
                shimmer = 0
            elif shimmer < 26:
                if (shimmer & 1) == 0:
                    if shimmer > 0:
                        self.colorram[base + (shimmer >> 1) - 1] = COLOR_MENU_SELECTED
                    if shimmer < 26:
                        self.colorram[base + (shimmer >> 1)] = WHITE
                shimmer += 1
                if shimmer == 26:
                    self.colorram[base + 12] = COLOR_MENU_SELECTED
                    shimmer = 90 + Random.range_mask(127)

            # Keyboard/joystick
            key = getkey()
            if key == KEY_UP or key == KEY_W or key == KEY_W_LOWER:
                if self.menu_selected > 0:
                    self.menu_selected -= 1
                    self.update_menu_highlight()
                    shimmer = 60 + Random.range_mask(63)

            elif key == KEY_DOWN or key == KEY_S or key == KEY_S_LOWER:
                if self.menu_selected < MENU_ITEM_COUNT - 1:
                    self.menu_selected += 1
                    self.update_menu_highlight()
                    shimmer = 60 + Random.range_mask(63)

            elif key == KEY_SPACE or key == KEY_RETURN:
                self.cleanup()
                break

    def __init__():
        # Initialize screen
        Screen.set_bitmap_mode()
        # Setup and enable raster IRQ for split screen
        __set_irq__(irq_title_handler)
        __enable_raster_irq__(TITLE_RASTER_TO_BITMAP)
        # Decompress and display image
        self.decompress_image()
        # Initialize star sprites for background effect
        Sprites.init_stars(title_star_positions_data, STAR_COLOR)


class StoryScreen:
    """Story screen - displays game backstory."""
    def draw():
        # Title - CYAN
        Screen.print_center(1, "DEEP SPACE COLONY K-7", CYAN, 0)
        Screen.print_center(2, "YEAR 2084", CYAN, 0)

        # Opening
        Screen.print_center(4, "THREE DAYS AGO IT APPEARED.", LIGHT_GREY, 0)

        # Description
        Screen.print_center(6, "A CRYSTALLINE MASS SPREADING", LIGHT_GREY, 0)
        Screen.print_center(7, "ACROSS THE HULL.", LIGHT_GREY, 0)
        Screen.print_center(8, "NO ORIGIN. NO WARNING.", LIGHT_GREY, 0)

        # Drama
        Screen.print_center(10, "AND IT KEEPS ACCELERATING.", WHITE, 0)
        Screen.print_center(11, "WE CALL IT THE CASCADE.", WHITE, 0)

        # Solution
        Screen.print_center(13, "THE RESEARCH COUNCIL FOUND ONE", LIGHT_GREY, 0)
        Screen.print_center(14, "WEAKNESS. VACCINES THROUGH GAPS", LIGHT_GREY, 0)
        Screen.print_center(15, "NEUTRALIZE ENTIRE COLUMNS.", LIGHT_GREY, 0)

        # Vaccine types
        Screen.print_center(17, "WHITE FADES. YELLOW DRILLS. BLUE STAYS.", LIGHT_GREY, 0)
        Screen.print_center(18, "USE WHAT YOU GET.", LIGHT_GREY, 0)
        Screen.print_center(19, "AIM FAST. SHOOT TRUE.", WHITE, 0)

        # Stakes
        Screen.print_center(21, "EVACUATION IN PROGRESS", YELLOW, 0)
        Screen.print_center(22, "13337 LIVES AT STAKE", YELLOW, 0)

    def __init__():
        Screen.sync_raster(IRQ_RASTER_BOTTOM)
        # Set game mode (ECM text mode)
        Screen.set_game_mode()
        # Draw story content
        self.draw()
        # Wait for keypress
        press_a_key(14, 24)


class AboutScreen:
    """About screen - game credits and instructions."""
    def draw():
        # Title
        Screen.print_center(1, "SLOTSHOT", CYAN, 0)

        # Credits
        Screen.print_center(4, "CREATED BY", LIGHT_GREY, 0)
        Screen.print_center(5, "ADAM WALLNER", WHITE, 0)

        # Copyright
        Screen.print_center(7, "COPYRIGHT 2025-2026", LIGHT_GREY, 0)
        Screen.print_center(8, "LICENSED UNDER GPL", LIGHT_GREY, 0)

        # Technology
        Screen.print_center(11, "WRITTEN IN", LIGHT_GREY, 0)
        Screen.print_center(12, "PYCO LANGUAGE", WHITE, 0)
        Screen.print_center(13, "FOR COMMODORE 64", LIGHT_GREY, 0)

        # How to play
        Screen.print_center(16, "HOW TO PLAY", YELLOW, 0)
        Screen.print_center(17, "FILL THE EMPTY CELLS", LIGHT_GREY, 0)
        Screen.print_center(18, "BY SHOOTING COLORED BLOCKS", LIGHT_GREY, 0)

        # Controls
        Screen.print_center(20, "CONTROLS", YELLOW, 0)
        Screen.print_center(21, "ARROWS / WASD / JOYSTICK 2", LIGHT_GREY, 0)
        Screen.print_center(22, "SPACE / FIRE", LIGHT_GREY, 0)

    def __init__():
        Screen.sync_raster(IRQ_RASTER_BOTTOM)
        # Set game mode (ECM text mode)
        Screen.set_game_mode()
        # Draw about content
        self.draw()
        # Wait for keypress
        press_a_key(14, 24)


class DonateScreen:
    """Donate screen - displays QR code for PayPal donation using ECM mode."""

    def draw_qr():
        """Draw 25x25 QR code from bitstream data, right-aligned."""
        pos: word
        row: byte
        col: byte
        byte_idx: byte = 0
        bit_mask: byte = 0x80
        data_byte: byte
        c: byte

        # QR code position: right side of screen (col 15 = 40-25)
        # Bitstream format: 625 bits continuous in 79 bytes, MSB first
        # Bit=1 -> $20 (black/BG0), Bit=0 -> $60 (white/BG1)
        # data_byte = qr_donate_data[0]
        # for row in range(25):
        #     pos = row_offset_data[row] + 15
        #     for col in range(25):
        #         if data_byte & bit_mask:
        #             c = CHAR_SPACE + BG_PLAY
        #         else:
        #             c = CHAR_SPACE + BG_HIGHLIGHT
        #         Screen.screen[pos] = c +
        #         pos += 1
        #         bit_mask = bit_mask >> 1
        #         if bit_mask == 0:
        #             bit_mask = 0x80
        #             byte_idx += 1
        #             data_byte = qr_donate_data[byte_idx]

    def draw():
        """Draw donate screen content (left side text)."""
        # Title
        Screen.print_at(2, 2, "DONATE ME", CYAN, 0)

        # Thank you message
        Screen.print_at(1, 6, "IF YOU LIKE", LIGHT_GREY, 0)
        Screen.print_at(2, 7, "SLOTSHOT,", WHITE, 0)
        Screen.print_at(1, 8, "SUPPORT ME!", LIGHT_GREY, 0)

        # QR instruction
        Screen.print_at(3, 11, "SCAN QR", YELLOW, 0)
        Screen.print_at(2, 12, "WITH YOUR", LIGHT_GREY, 0)
        Screen.print_at(4, 13, "PHONE", LIGHT_GREY, 0)

        # Thank you
        Screen.print_at(2, 16, "THANK YOU", GREEN, 0)

    def __init__():
        Screen.sync_raster(IRQ_RASTER_BOTTOM)
        Screen.set_game_mode()
        # Draw content
        # self.draw_qr()
        self.draw()
        # Wait for keypress
        press_a_key(1, 22)


# =============================================================================
# SCREEN CONTEXT FUNCTIONS
# With this the stack based memory allocated by the screens are freed when the
# screen is closed
# =============================================================================

@relocate(0xC140)
def title_screen():
    title_screen: TitleScreen
    title_screen()
    title_screen.wait_menu()


@relocate(0x200)
def story_screen():
    story_screen: StoryScreen
    story_screen()


@relocate(0x200)
def about_screen():
    about_screen: AboutScreen
    about_screen()


@relocate(0x200)
def donate_screen():
    donate_screen: DonateScreen
    donate_screen()
    pass


def game():
    game: Game
    game()


# =============================================================================
# MAIN
# =============================================================================

@charset_rom(0xC800)
@noreturn
def main():
    # Menu selection: 0=Play, 2=Story, 3=Credits
    menu_choice: byte[ZP_MENU_SELECTED] = 0

    # Initialize sprite data in VIC bank
    Sprites()

    # Initialize random number generator
    Random()

    # Initialize music player
    slotshot_music_vic_init()

    while True:
        # InitializeShow title screen and get menu selection
        title_screen()

        if menu_choice == 0:
            # Stop music
            music_stop_fade(15)
            # Start game
            game()
            # Continue music
            slotshot_music_vic_init()

        elif menu_choice == 1:
            story_screen()

        elif menu_choice == 2:
            about_screen()

        elif menu_choice == 3:
            donate_screen()
